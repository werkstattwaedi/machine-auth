// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TOKENSESSION_OWW_H_
#define FLATBUFFERS_GENERATED_TOKENSESSION_OWW_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "machine_usage_generated.h"
#include "ntag_generated.h"

#include "common.h"

namespace oww {

struct TokenSession;
struct TokenSessionBuilder;
struct TokenSessionT;

struct StartSessionRequest;
struct StartSessionRequestBuilder;
struct StartSessionRequestT;

struct AuthRequired;
struct AuthRequiredBuilder;
struct AuthRequiredT;

struct Rejected;
struct RejectedBuilder;
struct RejectedT;

struct StartSessionResponse;
struct StartSessionResponseBuilder;
struct StartSessionResponseT;

struct AuthenticateNewSessionRequest;
struct AuthenticateNewSessionRequestBuilder;
struct AuthenticateNewSessionRequestT;

struct AuthenticateNewSessionResponse;
struct AuthenticateNewSessionResponseBuilder;
struct AuthenticateNewSessionResponseT;

struct CompleteAuthenticationRequest;
struct CompleteAuthenticationRequestBuilder;
struct CompleteAuthenticationRequestT;

struct CompleteAuthenticationResponse;
struct CompleteAuthenticationResponseBuilder;
struct CompleteAuthenticationResponseT;

struct UploadUsageRequest;
struct UploadUsageRequestBuilder;
struct UploadUsageRequestT;

struct UploadUsageResponse;
struct UploadUsageResponseBuilder;
struct UploadUsageResponseT;

enum class StartSessionResult : uint8_t {
  NONE = 0,
  TokenSession = 1,
  AuthRequired = 2,
  Rejected = 3,
  MIN = NONE,
  MAX = Rejected
};

inline const StartSessionResult (&EnumValuesStartSessionResult())[4] {
  static const StartSessionResult values[] = {
    StartSessionResult::NONE,
    StartSessionResult::TokenSession,
    StartSessionResult::AuthRequired,
    StartSessionResult::Rejected
  };
  return values;
}

inline const char * const *EnumNamesStartSessionResult() {
  static const char * const names[5] = {
    "NONE",
    "TokenSession",
    "AuthRequired",
    "Rejected",
    nullptr
  };
  return names;
}

inline const char *EnumNameStartSessionResult(StartSessionResult e) {
  if (::flatbuffers::IsOutRange(e, StartSessionResult::NONE, StartSessionResult::Rejected)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStartSessionResult()[index];
}

template<typename T> struct StartSessionResultTraits {
  static const StartSessionResult enum_value = StartSessionResult::NONE;
};

template<> struct StartSessionResultTraits<oww::TokenSession> {
  static const StartSessionResult enum_value = StartSessionResult::TokenSession;
};

template<> struct StartSessionResultTraits<oww::AuthRequired> {
  static const StartSessionResult enum_value = StartSessionResult::AuthRequired;
};

template<> struct StartSessionResultTraits<oww::Rejected> {
  static const StartSessionResult enum_value = StartSessionResult::Rejected;
};

template<typename T> struct StartSessionResultUnionTraits {
  static const StartSessionResult enum_value = StartSessionResult::NONE;
};

template<> struct StartSessionResultUnionTraits<oww::TokenSessionT> {
  static const StartSessionResult enum_value = StartSessionResult::TokenSession;
};

template<> struct StartSessionResultUnionTraits<oww::AuthRequiredT> {
  static const StartSessionResult enum_value = StartSessionResult::AuthRequired;
};

template<> struct StartSessionResultUnionTraits<oww::RejectedT> {
  static const StartSessionResult enum_value = StartSessionResult::Rejected;
};

struct StartSessionResultUnion {
  StartSessionResult type;
  void *value;

  StartSessionResultUnion() : type(StartSessionResult::NONE), value(nullptr) {}
  StartSessionResultUnion(StartSessionResultUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(StartSessionResult::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  StartSessionResultUnion(const StartSessionResultUnion &);
  StartSessionResultUnion &operator=(const StartSessionResultUnion &u)
    { StartSessionResultUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  StartSessionResultUnion &operator=(StartSessionResultUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~StartSessionResultUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = StartSessionResultUnionTraits<RT>::enum_value;
    if (type != StartSessionResult::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, StartSessionResult type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  oww::TokenSessionT *AsTokenSession() {
    return type == StartSessionResult::TokenSession ?
      reinterpret_cast<oww::TokenSessionT *>(value) : nullptr;
  }
  const oww::TokenSessionT *AsTokenSession() const {
    return type == StartSessionResult::TokenSession ?
      reinterpret_cast<const oww::TokenSessionT *>(value) : nullptr;
  }
  oww::AuthRequiredT *AsAuthRequired() {
    return type == StartSessionResult::AuthRequired ?
      reinterpret_cast<oww::AuthRequiredT *>(value) : nullptr;
  }
  const oww::AuthRequiredT *AsAuthRequired() const {
    return type == StartSessionResult::AuthRequired ?
      reinterpret_cast<const oww::AuthRequiredT *>(value) : nullptr;
  }
  oww::RejectedT *AsRejected() {
    return type == StartSessionResult::Rejected ?
      reinterpret_cast<oww::RejectedT *>(value) : nullptr;
  }
  const oww::RejectedT *AsRejected() const {
    return type == StartSessionResult::Rejected ?
      reinterpret_cast<const oww::RejectedT *>(value) : nullptr;
  }
};

bool VerifyStartSessionResult(::flatbuffers::Verifier &verifier, const void *obj, StartSessionResult type);
bool VerifyStartSessionResultVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<StartSessionResult> *types);

enum class CompleteAuthenticationResult : uint8_t {
  NONE = 0,
  TokenSession = 1,
  Rejected = 2,
  MIN = NONE,
  MAX = Rejected
};

inline const CompleteAuthenticationResult (&EnumValuesCompleteAuthenticationResult())[3] {
  static const CompleteAuthenticationResult values[] = {
    CompleteAuthenticationResult::NONE,
    CompleteAuthenticationResult::TokenSession,
    CompleteAuthenticationResult::Rejected
  };
  return values;
}

inline const char * const *EnumNamesCompleteAuthenticationResult() {
  static const char * const names[4] = {
    "NONE",
    "TokenSession",
    "Rejected",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompleteAuthenticationResult(CompleteAuthenticationResult e) {
  if (::flatbuffers::IsOutRange(e, CompleteAuthenticationResult::NONE, CompleteAuthenticationResult::Rejected)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCompleteAuthenticationResult()[index];
}

template<typename T> struct CompleteAuthenticationResultTraits {
  static const CompleteAuthenticationResult enum_value = CompleteAuthenticationResult::NONE;
};

template<> struct CompleteAuthenticationResultTraits<oww::TokenSession> {
  static const CompleteAuthenticationResult enum_value = CompleteAuthenticationResult::TokenSession;
};

template<> struct CompleteAuthenticationResultTraits<oww::Rejected> {
  static const CompleteAuthenticationResult enum_value = CompleteAuthenticationResult::Rejected;
};

template<typename T> struct CompleteAuthenticationResultUnionTraits {
  static const CompleteAuthenticationResult enum_value = CompleteAuthenticationResult::NONE;
};

template<> struct CompleteAuthenticationResultUnionTraits<oww::TokenSessionT> {
  static const CompleteAuthenticationResult enum_value = CompleteAuthenticationResult::TokenSession;
};

template<> struct CompleteAuthenticationResultUnionTraits<oww::RejectedT> {
  static const CompleteAuthenticationResult enum_value = CompleteAuthenticationResult::Rejected;
};

struct CompleteAuthenticationResultUnion {
  CompleteAuthenticationResult type;
  void *value;

  CompleteAuthenticationResultUnion() : type(CompleteAuthenticationResult::NONE), value(nullptr) {}
  CompleteAuthenticationResultUnion(CompleteAuthenticationResultUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(CompleteAuthenticationResult::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CompleteAuthenticationResultUnion(const CompleteAuthenticationResultUnion &);
  CompleteAuthenticationResultUnion &operator=(const CompleteAuthenticationResultUnion &u)
    { CompleteAuthenticationResultUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CompleteAuthenticationResultUnion &operator=(CompleteAuthenticationResultUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CompleteAuthenticationResultUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = CompleteAuthenticationResultUnionTraits<RT>::enum_value;
    if (type != CompleteAuthenticationResult::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, CompleteAuthenticationResult type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  oww::TokenSessionT *AsTokenSession() {
    return type == CompleteAuthenticationResult::TokenSession ?
      reinterpret_cast<oww::TokenSessionT *>(value) : nullptr;
  }
  const oww::TokenSessionT *AsTokenSession() const {
    return type == CompleteAuthenticationResult::TokenSession ?
      reinterpret_cast<const oww::TokenSessionT *>(value) : nullptr;
  }
  oww::RejectedT *AsRejected() {
    return type == CompleteAuthenticationResult::Rejected ?
      reinterpret_cast<oww::RejectedT *>(value) : nullptr;
  }
  const oww::RejectedT *AsRejected() const {
    return type == CompleteAuthenticationResult::Rejected ?
      reinterpret_cast<const oww::RejectedT *>(value) : nullptr;
  }
};

bool VerifyCompleteAuthenticationResult(::flatbuffers::Verifier &verifier, const void *obj, CompleteAuthenticationResult type);
bool VerifyCompleteAuthenticationResultVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<CompleteAuthenticationResult> *types);

struct TokenSessionT : public ::flatbuffers::NativeTable {
  typedef TokenSession TableType;
  std::unique_ptr<oww::TagUid> token_id{};
  std::string session_id{};
  uint64_t expiration = 0;
  std::string user_id{};
  std::string user_label{};
  std::vector<std::string> permissions{};
  TokenSessionT() = default;
  TokenSessionT(const TokenSessionT &o);
  TokenSessionT(TokenSessionT&&) FLATBUFFERS_NOEXCEPT = default;
  TokenSessionT &operator=(TokenSessionT o) FLATBUFFERS_NOEXCEPT;
};

struct TokenSession FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TokenSessionT NativeTableType;
  typedef TokenSessionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN_ID = 4,
    VT_SESSION_ID = 6,
    VT_EXPIRATION = 8,
    VT_USER_ID = 10,
    VT_USER_LABEL = 12,
    VT_PERMISSIONS = 14
  };
  const oww::TagUid *token_id() const {
    return GetStruct<const oww::TagUid *>(VT_TOKEN_ID);
  }
  const ::flatbuffers::String *session_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_ID);
  }
  uint64_t expiration() const {
    return GetField<uint64_t>(VT_EXPIRATION, 0);
  }
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  const ::flatbuffers::String *user_label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_LABEL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *permissions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PERMISSIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<oww::TagUid>(verifier, VT_TOKEN_ID, 1) &&
           VerifyOffset(verifier, VT_SESSION_ID) &&
           verifier.VerifyString(session_id()) &&
           VerifyField<uint64_t>(verifier, VT_EXPIRATION, 8) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyOffset(verifier, VT_USER_LABEL) &&
           verifier.VerifyString(user_label()) &&
           VerifyOffset(verifier, VT_PERMISSIONS) &&
           verifier.VerifyVector(permissions()) &&
           verifier.VerifyVectorOfStrings(permissions()) &&
           verifier.EndTable();
  }
  TokenSessionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TokenSessionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TokenSession> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TokenSessionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TokenSessionBuilder {
  typedef TokenSession Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_token_id(const oww::TagUid *token_id) {
    fbb_.AddStruct(TokenSession::VT_TOKEN_ID, token_id);
  }
  void add_session_id(::flatbuffers::Offset<::flatbuffers::String> session_id) {
    fbb_.AddOffset(TokenSession::VT_SESSION_ID, session_id);
  }
  void add_expiration(uint64_t expiration) {
    fbb_.AddElement<uint64_t>(TokenSession::VT_EXPIRATION, expiration, 0);
  }
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(TokenSession::VT_USER_ID, user_id);
  }
  void add_user_label(::flatbuffers::Offset<::flatbuffers::String> user_label) {
    fbb_.AddOffset(TokenSession::VT_USER_LABEL, user_label);
  }
  void add_permissions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> permissions) {
    fbb_.AddOffset(TokenSession::VT_PERMISSIONS, permissions);
  }
  explicit TokenSessionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TokenSession> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TokenSession>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TokenSession> CreateTokenSession(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const oww::TagUid *token_id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> session_id = 0,
    uint64_t expiration = 0,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> user_label = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> permissions = 0) {
  TokenSessionBuilder builder_(_fbb);
  builder_.add_expiration(expiration);
  builder_.add_permissions(permissions);
  builder_.add_user_label(user_label);
  builder_.add_user_id(user_id);
  builder_.add_session_id(session_id);
  builder_.add_token_id(token_id);
  return builder_.Finish();
}

struct TokenSession::Traits {
  using type = TokenSession;
  static auto constexpr Create = CreateTokenSession;
};

inline ::flatbuffers::Offset<TokenSession> CreateTokenSessionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const oww::TagUid *token_id = nullptr,
    const char *session_id = nullptr,
    uint64_t expiration = 0,
    const char *user_id = nullptr,
    const char *user_label = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *permissions = nullptr) {
  auto session_id__ = session_id ? _fbb.CreateString(session_id) : 0;
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  auto user_label__ = user_label ? _fbb.CreateString(user_label) : 0;
  auto permissions__ = permissions ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*permissions) : 0;
  return oww::CreateTokenSession(
      _fbb,
      token_id,
      session_id__,
      expiration,
      user_id__,
      user_label__,
      permissions__);
}

::flatbuffers::Offset<TokenSession> CreateTokenSession(::flatbuffers::FlatBufferBuilder &_fbb, const TokenSessionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartSessionRequestT : public ::flatbuffers::NativeTable {
  typedef StartSessionRequest TableType;
  std::unique_ptr<oww::TagUid> token_id{};
  StartSessionRequestT() = default;
  StartSessionRequestT(const StartSessionRequestT &o);
  StartSessionRequestT(StartSessionRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  StartSessionRequestT &operator=(StartSessionRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct StartSessionRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartSessionRequestT NativeTableType;
  typedef StartSessionRequestBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN_ID = 4
  };
  const oww::TagUid *token_id() const {
    return GetStruct<const oww::TagUid *>(VT_TOKEN_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<oww::TagUid>(verifier, VT_TOKEN_ID, 1) &&
           verifier.EndTable();
  }
  StartSessionRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartSessionRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StartSessionRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StartSessionRequestBuilder {
  typedef StartSessionRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_token_id(const oww::TagUid *token_id) {
    fbb_.AddStruct(StartSessionRequest::VT_TOKEN_ID, token_id);
  }
  explicit StartSessionRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartSessionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartSessionRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartSessionRequest> CreateStartSessionRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const oww::TagUid *token_id = nullptr) {
  StartSessionRequestBuilder builder_(_fbb);
  builder_.add_token_id(token_id);
  return builder_.Finish();
}

struct StartSessionRequest::Traits {
  using type = StartSessionRequest;
  static auto constexpr Create = CreateStartSessionRequest;
};

::flatbuffers::Offset<StartSessionRequest> CreateStartSessionRequest(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthRequiredT : public ::flatbuffers::NativeTable {
  typedef AuthRequired TableType;
};

struct AuthRequired FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthRequiredT NativeTableType;
  typedef AuthRequiredBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AuthRequiredT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthRequiredT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AuthRequired> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRequiredT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthRequiredBuilder {
  typedef AuthRequired Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit AuthRequiredBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AuthRequired> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AuthRequired>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AuthRequired> CreateAuthRequired(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  AuthRequiredBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AuthRequired::Traits {
  using type = AuthRequired;
  static auto constexpr Create = CreateAuthRequired;
};

::flatbuffers::Offset<AuthRequired> CreateAuthRequired(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRequiredT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RejectedT : public ::flatbuffers::NativeTable {
  typedef Rejected TableType;
  std::string message{};
};

struct Rejected FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RejectedT NativeTableType;
  typedef RejectedBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4
  };
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  RejectedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RejectedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Rejected> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RejectedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RejectedBuilder {
  typedef Rejected Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Rejected::VT_MESSAGE, message);
  }
  explicit RejectedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Rejected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Rejected>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Rejected> CreateRejected(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  RejectedBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

struct Rejected::Traits {
  using type = Rejected;
  static auto constexpr Create = CreateRejected;
};

inline ::flatbuffers::Offset<Rejected> CreateRejectedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return oww::CreateRejected(
      _fbb,
      message__);
}

::flatbuffers::Offset<Rejected> CreateRejected(::flatbuffers::FlatBufferBuilder &_fbb, const RejectedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartSessionResponseT : public ::flatbuffers::NativeTable {
  typedef StartSessionResponse TableType;
  oww::StartSessionResultUnion result{};
};

struct StartSessionResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartSessionResponseT NativeTableType;
  typedef StartSessionResponseBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT_TYPE = 4,
    VT_RESULT = 6
  };
  oww::StartSessionResult result_type() const {
    return static_cast<oww::StartSessionResult>(GetField<uint8_t>(VT_RESULT_TYPE, 0));
  }
  const void *result() const {
    return GetPointer<const void *>(VT_RESULT);
  }
  template<typename T> const T *result_as() const;
  const oww::TokenSession *result_as_TokenSession() const {
    return result_type() == oww::StartSessionResult::TokenSession ? static_cast<const oww::TokenSession *>(result()) : nullptr;
  }
  const oww::AuthRequired *result_as_AuthRequired() const {
    return result_type() == oww::StartSessionResult::AuthRequired ? static_cast<const oww::AuthRequired *>(result()) : nullptr;
  }
  const oww::Rejected *result_as_Rejected() const {
    return result_type() == oww::StartSessionResult::Rejected ? static_cast<const oww::Rejected *>(result()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESULT) &&
           VerifyStartSessionResult(verifier, result(), result_type()) &&
           verifier.EndTable();
  }
  StartSessionResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartSessionResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StartSessionResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const oww::TokenSession *StartSessionResponse::result_as<oww::TokenSession>() const {
  return result_as_TokenSession();
}

template<> inline const oww::AuthRequired *StartSessionResponse::result_as<oww::AuthRequired>() const {
  return result_as_AuthRequired();
}

template<> inline const oww::Rejected *StartSessionResponse::result_as<oww::Rejected>() const {
  return result_as_Rejected();
}

struct StartSessionResponseBuilder {
  typedef StartSessionResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result_type(oww::StartSessionResult result_type) {
    fbb_.AddElement<uint8_t>(StartSessionResponse::VT_RESULT_TYPE, static_cast<uint8_t>(result_type), 0);
  }
  void add_result(::flatbuffers::Offset<void> result) {
    fbb_.AddOffset(StartSessionResponse::VT_RESULT, result);
  }
  explicit StartSessionResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartSessionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartSessionResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartSessionResponse> CreateStartSessionResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    oww::StartSessionResult result_type = oww::StartSessionResult::NONE,
    ::flatbuffers::Offset<void> result = 0) {
  StartSessionResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_result_type(result_type);
  return builder_.Finish();
}

struct StartSessionResponse::Traits {
  using type = StartSessionResponse;
  static auto constexpr Create = CreateStartSessionResponse;
};

::flatbuffers::Offset<StartSessionResponse> CreateStartSessionResponse(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticateNewSessionRequestT : public ::flatbuffers::NativeTable {
  typedef AuthenticateNewSessionRequest TableType;
  std::unique_ptr<oww::TagUid> token_id{};
  std::vector<uint8_t> ntag_challenge{};
  AuthenticateNewSessionRequestT() = default;
  AuthenticateNewSessionRequestT(const AuthenticateNewSessionRequestT &o);
  AuthenticateNewSessionRequestT(AuthenticateNewSessionRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  AuthenticateNewSessionRequestT &operator=(AuthenticateNewSessionRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct AuthenticateNewSessionRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthenticateNewSessionRequestT NativeTableType;
  typedef AuthenticateNewSessionRequestBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN_ID = 4,
    VT_NTAG_CHALLENGE = 6
  };
  const oww::TagUid *token_id() const {
    return GetStruct<const oww::TagUid *>(VT_TOKEN_ID);
  }
  const ::flatbuffers::Vector<uint8_t> *ntag_challenge() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_NTAG_CHALLENGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<oww::TagUid>(verifier, VT_TOKEN_ID, 1) &&
           VerifyOffset(verifier, VT_NTAG_CHALLENGE) &&
           verifier.VerifyVector(ntag_challenge()) &&
           verifier.EndTable();
  }
  AuthenticateNewSessionRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthenticateNewSessionRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AuthenticateNewSessionRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateNewSessionRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthenticateNewSessionRequestBuilder {
  typedef AuthenticateNewSessionRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_token_id(const oww::TagUid *token_id) {
    fbb_.AddStruct(AuthenticateNewSessionRequest::VT_TOKEN_ID, token_id);
  }
  void add_ntag_challenge(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ntag_challenge) {
    fbb_.AddOffset(AuthenticateNewSessionRequest::VT_NTAG_CHALLENGE, ntag_challenge);
  }
  explicit AuthenticateNewSessionRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AuthenticateNewSessionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AuthenticateNewSessionRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AuthenticateNewSessionRequest> CreateAuthenticateNewSessionRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const oww::TagUid *token_id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ntag_challenge = 0) {
  AuthenticateNewSessionRequestBuilder builder_(_fbb);
  builder_.add_ntag_challenge(ntag_challenge);
  builder_.add_token_id(token_id);
  return builder_.Finish();
}

struct AuthenticateNewSessionRequest::Traits {
  using type = AuthenticateNewSessionRequest;
  static auto constexpr Create = CreateAuthenticateNewSessionRequest;
};

inline ::flatbuffers::Offset<AuthenticateNewSessionRequest> CreateAuthenticateNewSessionRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const oww::TagUid *token_id = nullptr,
    const std::vector<uint8_t> *ntag_challenge = nullptr) {
  auto ntag_challenge__ = ntag_challenge ? _fbb.CreateVector<uint8_t>(*ntag_challenge) : 0;
  return oww::CreateAuthenticateNewSessionRequest(
      _fbb,
      token_id,
      ntag_challenge__);
}

::flatbuffers::Offset<AuthenticateNewSessionRequest> CreateAuthenticateNewSessionRequest(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateNewSessionRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticateNewSessionResponseT : public ::flatbuffers::NativeTable {
  typedef AuthenticateNewSessionResponse TableType;
  std::string session_id{};
  std::vector<uint8_t> cloud_challenge{};
};

struct AuthenticateNewSessionResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthenticateNewSessionResponseT NativeTableType;
  typedef AuthenticateNewSessionResponseBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4,
    VT_CLOUD_CHALLENGE = 6
  };
  const ::flatbuffers::String *session_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_ID);
  }
  const ::flatbuffers::Vector<uint8_t> *cloud_challenge() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CLOUD_CHALLENGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION_ID) &&
           verifier.VerifyString(session_id()) &&
           VerifyOffset(verifier, VT_CLOUD_CHALLENGE) &&
           verifier.VerifyVector(cloud_challenge()) &&
           verifier.EndTable();
  }
  AuthenticateNewSessionResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthenticateNewSessionResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AuthenticateNewSessionResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateNewSessionResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthenticateNewSessionResponseBuilder {
  typedef AuthenticateNewSessionResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(::flatbuffers::Offset<::flatbuffers::String> session_id) {
    fbb_.AddOffset(AuthenticateNewSessionResponse::VT_SESSION_ID, session_id);
  }
  void add_cloud_challenge(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> cloud_challenge) {
    fbb_.AddOffset(AuthenticateNewSessionResponse::VT_CLOUD_CHALLENGE, cloud_challenge);
  }
  explicit AuthenticateNewSessionResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AuthenticateNewSessionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AuthenticateNewSessionResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AuthenticateNewSessionResponse> CreateAuthenticateNewSessionResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> session_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> cloud_challenge = 0) {
  AuthenticateNewSessionResponseBuilder builder_(_fbb);
  builder_.add_cloud_challenge(cloud_challenge);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

struct AuthenticateNewSessionResponse::Traits {
  using type = AuthenticateNewSessionResponse;
  static auto constexpr Create = CreateAuthenticateNewSessionResponse;
};

inline ::flatbuffers::Offset<AuthenticateNewSessionResponse> CreateAuthenticateNewSessionResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_id = nullptr,
    const std::vector<uint8_t> *cloud_challenge = nullptr) {
  auto session_id__ = session_id ? _fbb.CreateString(session_id) : 0;
  auto cloud_challenge__ = cloud_challenge ? _fbb.CreateVector<uint8_t>(*cloud_challenge) : 0;
  return oww::CreateAuthenticateNewSessionResponse(
      _fbb,
      session_id__,
      cloud_challenge__);
}

::flatbuffers::Offset<AuthenticateNewSessionResponse> CreateAuthenticateNewSessionResponse(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateNewSessionResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CompleteAuthenticationRequestT : public ::flatbuffers::NativeTable {
  typedef CompleteAuthenticationRequest TableType;
  std::string session_id{};
  std::vector<uint8_t> encrypted_ntag_response{};
};

struct CompleteAuthenticationRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompleteAuthenticationRequestT NativeTableType;
  typedef CompleteAuthenticationRequestBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4,
    VT_ENCRYPTED_NTAG_RESPONSE = 6
  };
  const ::flatbuffers::String *session_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_ID);
  }
  const ::flatbuffers::Vector<uint8_t> *encrypted_ntag_response() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ENCRYPTED_NTAG_RESPONSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION_ID) &&
           verifier.VerifyString(session_id()) &&
           VerifyOffset(verifier, VT_ENCRYPTED_NTAG_RESPONSE) &&
           verifier.VerifyVector(encrypted_ntag_response()) &&
           verifier.EndTable();
  }
  CompleteAuthenticationRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CompleteAuthenticationRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CompleteAuthenticationRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CompleteAuthenticationRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CompleteAuthenticationRequestBuilder {
  typedef CompleteAuthenticationRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(::flatbuffers::Offset<::flatbuffers::String> session_id) {
    fbb_.AddOffset(CompleteAuthenticationRequest::VT_SESSION_ID, session_id);
  }
  void add_encrypted_ntag_response(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> encrypted_ntag_response) {
    fbb_.AddOffset(CompleteAuthenticationRequest::VT_ENCRYPTED_NTAG_RESPONSE, encrypted_ntag_response);
  }
  explicit CompleteAuthenticationRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompleteAuthenticationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompleteAuthenticationRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CompleteAuthenticationRequest> CreateCompleteAuthenticationRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> session_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> encrypted_ntag_response = 0) {
  CompleteAuthenticationRequestBuilder builder_(_fbb);
  builder_.add_encrypted_ntag_response(encrypted_ntag_response);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

struct CompleteAuthenticationRequest::Traits {
  using type = CompleteAuthenticationRequest;
  static auto constexpr Create = CreateCompleteAuthenticationRequest;
};

inline ::flatbuffers::Offset<CompleteAuthenticationRequest> CreateCompleteAuthenticationRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_id = nullptr,
    const std::vector<uint8_t> *encrypted_ntag_response = nullptr) {
  auto session_id__ = session_id ? _fbb.CreateString(session_id) : 0;
  auto encrypted_ntag_response__ = encrypted_ntag_response ? _fbb.CreateVector<uint8_t>(*encrypted_ntag_response) : 0;
  return oww::CreateCompleteAuthenticationRequest(
      _fbb,
      session_id__,
      encrypted_ntag_response__);
}

::flatbuffers::Offset<CompleteAuthenticationRequest> CreateCompleteAuthenticationRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CompleteAuthenticationRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CompleteAuthenticationResponseT : public ::flatbuffers::NativeTable {
  typedef CompleteAuthenticationResponse TableType;
  oww::CompleteAuthenticationResultUnion result{};
};

struct CompleteAuthenticationResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompleteAuthenticationResponseT NativeTableType;
  typedef CompleteAuthenticationResponseBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT_TYPE = 4,
    VT_RESULT = 6
  };
  oww::CompleteAuthenticationResult result_type() const {
    return static_cast<oww::CompleteAuthenticationResult>(GetField<uint8_t>(VT_RESULT_TYPE, 0));
  }
  const void *result() const {
    return GetPointer<const void *>(VT_RESULT);
  }
  template<typename T> const T *result_as() const;
  const oww::TokenSession *result_as_TokenSession() const {
    return result_type() == oww::CompleteAuthenticationResult::TokenSession ? static_cast<const oww::TokenSession *>(result()) : nullptr;
  }
  const oww::Rejected *result_as_Rejected() const {
    return result_type() == oww::CompleteAuthenticationResult::Rejected ? static_cast<const oww::Rejected *>(result()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESULT) &&
           VerifyCompleteAuthenticationResult(verifier, result(), result_type()) &&
           verifier.EndTable();
  }
  CompleteAuthenticationResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CompleteAuthenticationResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CompleteAuthenticationResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CompleteAuthenticationResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const oww::TokenSession *CompleteAuthenticationResponse::result_as<oww::TokenSession>() const {
  return result_as_TokenSession();
}

template<> inline const oww::Rejected *CompleteAuthenticationResponse::result_as<oww::Rejected>() const {
  return result_as_Rejected();
}

struct CompleteAuthenticationResponseBuilder {
  typedef CompleteAuthenticationResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result_type(oww::CompleteAuthenticationResult result_type) {
    fbb_.AddElement<uint8_t>(CompleteAuthenticationResponse::VT_RESULT_TYPE, static_cast<uint8_t>(result_type), 0);
  }
  void add_result(::flatbuffers::Offset<void> result) {
    fbb_.AddOffset(CompleteAuthenticationResponse::VT_RESULT, result);
  }
  explicit CompleteAuthenticationResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompleteAuthenticationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompleteAuthenticationResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CompleteAuthenticationResponse> CreateCompleteAuthenticationResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    oww::CompleteAuthenticationResult result_type = oww::CompleteAuthenticationResult::NONE,
    ::flatbuffers::Offset<void> result = 0) {
  CompleteAuthenticationResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_result_type(result_type);
  return builder_.Finish();
}

struct CompleteAuthenticationResponse::Traits {
  using type = CompleteAuthenticationResponse;
  static auto constexpr Create = CreateCompleteAuthenticationResponse;
};

::flatbuffers::Offset<CompleteAuthenticationResponse> CreateCompleteAuthenticationResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CompleteAuthenticationResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UploadUsageRequestT : public ::flatbuffers::NativeTable {
  typedef UploadUsageRequest TableType;
  std::unique_ptr<oww::MachineUsageHistoryT> history{};
  UploadUsageRequestT() = default;
  UploadUsageRequestT(const UploadUsageRequestT &o);
  UploadUsageRequestT(UploadUsageRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  UploadUsageRequestT &operator=(UploadUsageRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct UploadUsageRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UploadUsageRequestT NativeTableType;
  typedef UploadUsageRequestBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HISTORY = 4
  };
  const oww::MachineUsageHistory *history() const {
    return GetPointer<const oww::MachineUsageHistory *>(VT_HISTORY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HISTORY) &&
           verifier.VerifyTable(history()) &&
           verifier.EndTable();
  }
  UploadUsageRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UploadUsageRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UploadUsageRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UploadUsageRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UploadUsageRequestBuilder {
  typedef UploadUsageRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_history(::flatbuffers::Offset<oww::MachineUsageHistory> history) {
    fbb_.AddOffset(UploadUsageRequest::VT_HISTORY, history);
  }
  explicit UploadUsageRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UploadUsageRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UploadUsageRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UploadUsageRequest> CreateUploadUsageRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<oww::MachineUsageHistory> history = 0) {
  UploadUsageRequestBuilder builder_(_fbb);
  builder_.add_history(history);
  return builder_.Finish();
}

struct UploadUsageRequest::Traits {
  using type = UploadUsageRequest;
  static auto constexpr Create = CreateUploadUsageRequest;
};

::flatbuffers::Offset<UploadUsageRequest> CreateUploadUsageRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UploadUsageRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UploadUsageResponseT : public ::flatbuffers::NativeTable {
  typedef UploadUsageResponse TableType;
  bool success = false;
};

struct UploadUsageResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UploadUsageResponseT NativeTableType;
  typedef UploadUsageResponseBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  UploadUsageResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UploadUsageResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UploadUsageResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UploadUsageResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UploadUsageResponseBuilder {
  typedef UploadUsageResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(UploadUsageResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit UploadUsageResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UploadUsageResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UploadUsageResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UploadUsageResponse> CreateUploadUsageResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  UploadUsageResponseBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct UploadUsageResponse::Traits {
  using type = UploadUsageResponse;
  static auto constexpr Create = CreateUploadUsageResponse;
};

::flatbuffers::Offset<UploadUsageResponse> CreateUploadUsageResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UploadUsageResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TokenSessionT::TokenSessionT(const TokenSessionT &o)
      : token_id((o.token_id) ? new oww::TagUid(*o.token_id) : nullptr),
        session_id(o.session_id),
        expiration(o.expiration),
        user_id(o.user_id),
        user_label(o.user_label),
        permissions(o.permissions) {
}

inline TokenSessionT &TokenSessionT::operator=(TokenSessionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(token_id, o.token_id);
  std::swap(session_id, o.session_id);
  std::swap(expiration, o.expiration);
  std::swap(user_id, o.user_id);
  std::swap(user_label, o.user_label);
  std::swap(permissions, o.permissions);
  return *this;
}

inline TokenSessionT *TokenSession::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TokenSessionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TokenSession::UnPackTo(TokenSessionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = token_id(); if (_e) _o->token_id = std::unique_ptr<oww::TagUid>(new oww::TagUid(*_e)); }
  { auto _e = session_id(); if (_e) _o->session_id = _e->str(); }
  { auto _e = expiration(); _o->expiration = _e; }
  { auto _e = user_id(); if (_e) _o->user_id = _e->str(); }
  { auto _e = user_label(); if (_e) _o->user_label = _e->str(); }
  { auto _e = permissions(); if (_e) { _o->permissions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->permissions[_i] = _e->Get(_i)->str(); } } else { _o->permissions.resize(0); } }
}

inline ::flatbuffers::Offset<TokenSession> TokenSession::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TokenSessionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTokenSession(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TokenSession> CreateTokenSession(::flatbuffers::FlatBufferBuilder &_fbb, const TokenSessionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TokenSessionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _token_id = _o->token_id ? _o->token_id.get() : nullptr;
  auto _session_id = _o->session_id.empty() ? 0 : _fbb.CreateString(_o->session_id);
  auto _expiration = _o->expiration;
  auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
  auto _user_label = _o->user_label.empty() ? 0 : _fbb.CreateString(_o->user_label);
  auto _permissions = _o->permissions.size() ? _fbb.CreateVectorOfStrings(_o->permissions) : 0;
  return oww::CreateTokenSession(
      _fbb,
      _token_id,
      _session_id,
      _expiration,
      _user_id,
      _user_label,
      _permissions);
}

inline StartSessionRequestT::StartSessionRequestT(const StartSessionRequestT &o)
      : token_id((o.token_id) ? new oww::TagUid(*o.token_id) : nullptr) {
}

inline StartSessionRequestT &StartSessionRequestT::operator=(StartSessionRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(token_id, o.token_id);
  return *this;
}

inline StartSessionRequestT *StartSessionRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StartSessionRequestT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StartSessionRequest::UnPackTo(StartSessionRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = token_id(); if (_e) _o->token_id = std::unique_ptr<oww::TagUid>(new oww::TagUid(*_e)); }
}

inline ::flatbuffers::Offset<StartSessionRequest> StartSessionRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStartSessionRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StartSessionRequest> CreateStartSessionRequest(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StartSessionRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _token_id = _o->token_id ? _o->token_id.get() : nullptr;
  return oww::CreateStartSessionRequest(
      _fbb,
      _token_id);
}

inline AuthRequiredT *AuthRequired::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AuthRequiredT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AuthRequired::UnPackTo(AuthRequiredT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<AuthRequired> AuthRequired::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRequiredT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthRequired(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AuthRequired> CreateAuthRequired(::flatbuffers::FlatBufferBuilder &_fbb, const AuthRequiredT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AuthRequiredT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return oww::CreateAuthRequired(
      _fbb);
}

inline RejectedT *Rejected::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RejectedT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rejected::UnPackTo(RejectedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<Rejected> Rejected::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RejectedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRejected(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Rejected> CreateRejected(::flatbuffers::FlatBufferBuilder &_fbb, const RejectedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RejectedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return oww::CreateRejected(
      _fbb,
      _message);
}

inline StartSessionResponseT *StartSessionResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StartSessionResponseT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StartSessionResponse::UnPackTo(StartSessionResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result_type(); _o->result.type = _e; }
  { auto _e = result(); if (_e) _o->result.value = oww::StartSessionResultUnion::UnPack(_e, result_type(), _resolver); }
}

inline ::flatbuffers::Offset<StartSessionResponse> StartSessionResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStartSessionResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StartSessionResponse> CreateStartSessionResponse(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StartSessionResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result_type = _o->result.type;
  auto _result = _o->result.Pack(_fbb);
  return oww::CreateStartSessionResponse(
      _fbb,
      _result_type,
      _result);
}

inline AuthenticateNewSessionRequestT::AuthenticateNewSessionRequestT(const AuthenticateNewSessionRequestT &o)
      : token_id((o.token_id) ? new oww::TagUid(*o.token_id) : nullptr),
        ntag_challenge(o.ntag_challenge) {
}

inline AuthenticateNewSessionRequestT &AuthenticateNewSessionRequestT::operator=(AuthenticateNewSessionRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(token_id, o.token_id);
  std::swap(ntag_challenge, o.ntag_challenge);
  return *this;
}

inline AuthenticateNewSessionRequestT *AuthenticateNewSessionRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AuthenticateNewSessionRequestT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AuthenticateNewSessionRequest::UnPackTo(AuthenticateNewSessionRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = token_id(); if (_e) _o->token_id = std::unique_ptr<oww::TagUid>(new oww::TagUid(*_e)); }
  { auto _e = ntag_challenge(); if (_e) { _o->ntag_challenge.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->ntag_challenge.begin()); } }
}

inline ::flatbuffers::Offset<AuthenticateNewSessionRequest> AuthenticateNewSessionRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateNewSessionRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthenticateNewSessionRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AuthenticateNewSessionRequest> CreateAuthenticateNewSessionRequest(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateNewSessionRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AuthenticateNewSessionRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _token_id = _o->token_id ? _o->token_id.get() : nullptr;
  auto _ntag_challenge = _o->ntag_challenge.size() ? _fbb.CreateVector(_o->ntag_challenge) : 0;
  return oww::CreateAuthenticateNewSessionRequest(
      _fbb,
      _token_id,
      _ntag_challenge);
}

inline AuthenticateNewSessionResponseT *AuthenticateNewSessionResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AuthenticateNewSessionResponseT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AuthenticateNewSessionResponse::UnPackTo(AuthenticateNewSessionResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); if (_e) _o->session_id = _e->str(); }
  { auto _e = cloud_challenge(); if (_e) { _o->cloud_challenge.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->cloud_challenge.begin()); } }
}

inline ::flatbuffers::Offset<AuthenticateNewSessionResponse> AuthenticateNewSessionResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateNewSessionResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthenticateNewSessionResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AuthenticateNewSessionResponse> CreateAuthenticateNewSessionResponse(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticateNewSessionResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AuthenticateNewSessionResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _session_id = _o->session_id.empty() ? 0 : _fbb.CreateString(_o->session_id);
  auto _cloud_challenge = _o->cloud_challenge.size() ? _fbb.CreateVector(_o->cloud_challenge) : 0;
  return oww::CreateAuthenticateNewSessionResponse(
      _fbb,
      _session_id,
      _cloud_challenge);
}

inline CompleteAuthenticationRequestT *CompleteAuthenticationRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CompleteAuthenticationRequestT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CompleteAuthenticationRequest::UnPackTo(CompleteAuthenticationRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); if (_e) _o->session_id = _e->str(); }
  { auto _e = encrypted_ntag_response(); if (_e) { _o->encrypted_ntag_response.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->encrypted_ntag_response.begin()); } }
}

inline ::flatbuffers::Offset<CompleteAuthenticationRequest> CompleteAuthenticationRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CompleteAuthenticationRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCompleteAuthenticationRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CompleteAuthenticationRequest> CreateCompleteAuthenticationRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CompleteAuthenticationRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CompleteAuthenticationRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _session_id = _o->session_id.empty() ? 0 : _fbb.CreateString(_o->session_id);
  auto _encrypted_ntag_response = _o->encrypted_ntag_response.size() ? _fbb.CreateVector(_o->encrypted_ntag_response) : 0;
  return oww::CreateCompleteAuthenticationRequest(
      _fbb,
      _session_id,
      _encrypted_ntag_response);
}

inline CompleteAuthenticationResponseT *CompleteAuthenticationResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CompleteAuthenticationResponseT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CompleteAuthenticationResponse::UnPackTo(CompleteAuthenticationResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result_type(); _o->result.type = _e; }
  { auto _e = result(); if (_e) _o->result.value = oww::CompleteAuthenticationResultUnion::UnPack(_e, result_type(), _resolver); }
}

inline ::flatbuffers::Offset<CompleteAuthenticationResponse> CompleteAuthenticationResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CompleteAuthenticationResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCompleteAuthenticationResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CompleteAuthenticationResponse> CreateCompleteAuthenticationResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CompleteAuthenticationResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CompleteAuthenticationResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result_type = _o->result.type;
  auto _result = _o->result.Pack(_fbb);
  return oww::CreateCompleteAuthenticationResponse(
      _fbb,
      _result_type,
      _result);
}

inline UploadUsageRequestT::UploadUsageRequestT(const UploadUsageRequestT &o)
      : history((o.history) ? new oww::MachineUsageHistoryT(*o.history) : nullptr) {
}

inline UploadUsageRequestT &UploadUsageRequestT::operator=(UploadUsageRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(history, o.history);
  return *this;
}

inline UploadUsageRequestT *UploadUsageRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UploadUsageRequestT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UploadUsageRequest::UnPackTo(UploadUsageRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = history(); if (_e) { if(_o->history) { _e->UnPackTo(_o->history.get(), _resolver); } else { _o->history = std::unique_ptr<oww::MachineUsageHistoryT>(_e->UnPack(_resolver)); } } else if (_o->history) { _o->history.reset(); } }
}

inline ::flatbuffers::Offset<UploadUsageRequest> UploadUsageRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UploadUsageRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUploadUsageRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UploadUsageRequest> CreateUploadUsageRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UploadUsageRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UploadUsageRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _history = _o->history ? CreateMachineUsageHistory(_fbb, _o->history.get(), _rehasher) : 0;
  return oww::CreateUploadUsageRequest(
      _fbb,
      _history);
}

inline UploadUsageResponseT *UploadUsageResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UploadUsageResponseT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UploadUsageResponse::UnPackTo(UploadUsageResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<UploadUsageResponse> UploadUsageResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UploadUsageResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUploadUsageResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UploadUsageResponse> CreateUploadUsageResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UploadUsageResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UploadUsageResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _success = _o->success;
  return oww::CreateUploadUsageResponse(
      _fbb,
      _success);
}

inline bool VerifyStartSessionResult(::flatbuffers::Verifier &verifier, const void *obj, StartSessionResult type) {
  switch (type) {
    case StartSessionResult::NONE: {
      return true;
    }
    case StartSessionResult::TokenSession: {
      auto ptr = reinterpret_cast<const oww::TokenSession *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StartSessionResult::AuthRequired: {
      auto ptr = reinterpret_cast<const oww::AuthRequired *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StartSessionResult::Rejected: {
      auto ptr = reinterpret_cast<const oww::Rejected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyStartSessionResultVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<StartSessionResult> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyStartSessionResult(
        verifier,  values->Get(i), types->GetEnum<StartSessionResult>(i))) {
      return false;
    }
  }
  return true;
}

inline void *StartSessionResultUnion::UnPack(const void *obj, StartSessionResult type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case StartSessionResult::TokenSession: {
      auto ptr = reinterpret_cast<const oww::TokenSession *>(obj);
      return ptr->UnPack(resolver);
    }
    case StartSessionResult::AuthRequired: {
      auto ptr = reinterpret_cast<const oww::AuthRequired *>(obj);
      return ptr->UnPack(resolver);
    }
    case StartSessionResult::Rejected: {
      auto ptr = reinterpret_cast<const oww::Rejected *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> StartSessionResultUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case StartSessionResult::TokenSession: {
      auto ptr = reinterpret_cast<const oww::TokenSessionT *>(value);
      return CreateTokenSession(_fbb, ptr, _rehasher).Union();
    }
    case StartSessionResult::AuthRequired: {
      auto ptr = reinterpret_cast<const oww::AuthRequiredT *>(value);
      return CreateAuthRequired(_fbb, ptr, _rehasher).Union();
    }
    case StartSessionResult::Rejected: {
      auto ptr = reinterpret_cast<const oww::RejectedT *>(value);
      return CreateRejected(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline StartSessionResultUnion::StartSessionResultUnion(const StartSessionResultUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case StartSessionResult::TokenSession: {
      value = new oww::TokenSessionT(*reinterpret_cast<oww::TokenSessionT *>(u.value));
      break;
    }
    case StartSessionResult::AuthRequired: {
      value = new oww::AuthRequiredT(*reinterpret_cast<oww::AuthRequiredT *>(u.value));
      break;
    }
    case StartSessionResult::Rejected: {
      value = new oww::RejectedT(*reinterpret_cast<oww::RejectedT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void StartSessionResultUnion::Reset() {
  switch (type) {
    case StartSessionResult::TokenSession: {
      auto ptr = reinterpret_cast<oww::TokenSessionT *>(value);
      delete ptr;
      break;
    }
    case StartSessionResult::AuthRequired: {
      auto ptr = reinterpret_cast<oww::AuthRequiredT *>(value);
      delete ptr;
      break;
    }
    case StartSessionResult::Rejected: {
      auto ptr = reinterpret_cast<oww::RejectedT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = StartSessionResult::NONE;
}

inline bool VerifyCompleteAuthenticationResult(::flatbuffers::Verifier &verifier, const void *obj, CompleteAuthenticationResult type) {
  switch (type) {
    case CompleteAuthenticationResult::NONE: {
      return true;
    }
    case CompleteAuthenticationResult::TokenSession: {
      auto ptr = reinterpret_cast<const oww::TokenSession *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompleteAuthenticationResult::Rejected: {
      auto ptr = reinterpret_cast<const oww::Rejected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCompleteAuthenticationResultVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<CompleteAuthenticationResult> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCompleteAuthenticationResult(
        verifier,  values->Get(i), types->GetEnum<CompleteAuthenticationResult>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CompleteAuthenticationResultUnion::UnPack(const void *obj, CompleteAuthenticationResult type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case CompleteAuthenticationResult::TokenSession: {
      auto ptr = reinterpret_cast<const oww::TokenSession *>(obj);
      return ptr->UnPack(resolver);
    }
    case CompleteAuthenticationResult::Rejected: {
      auto ptr = reinterpret_cast<const oww::Rejected *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> CompleteAuthenticationResultUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case CompleteAuthenticationResult::TokenSession: {
      auto ptr = reinterpret_cast<const oww::TokenSessionT *>(value);
      return CreateTokenSession(_fbb, ptr, _rehasher).Union();
    }
    case CompleteAuthenticationResult::Rejected: {
      auto ptr = reinterpret_cast<const oww::RejectedT *>(value);
      return CreateRejected(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline CompleteAuthenticationResultUnion::CompleteAuthenticationResultUnion(const CompleteAuthenticationResultUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case CompleteAuthenticationResult::TokenSession: {
      value = new oww::TokenSessionT(*reinterpret_cast<oww::TokenSessionT *>(u.value));
      break;
    }
    case CompleteAuthenticationResult::Rejected: {
      value = new oww::RejectedT(*reinterpret_cast<oww::RejectedT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CompleteAuthenticationResultUnion::Reset() {
  switch (type) {
    case CompleteAuthenticationResult::TokenSession: {
      auto ptr = reinterpret_cast<oww::TokenSessionT *>(value);
      delete ptr;
      break;
    }
    case CompleteAuthenticationResult::Rejected: {
      auto ptr = reinterpret_cast<oww::RejectedT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = CompleteAuthenticationResult::NONE;
}

}  // namespace oww

#endif  // FLATBUFFERS_GENERATED_TOKENSESSION_OWW_H_
