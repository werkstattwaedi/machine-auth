// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MACHINEUSAGE_FBS_H_
#define FLATBUFFERS_GENERATED_MACHINEUSAGE_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "ntag_generated.h"

#include "common.h"

namespace fbs {

struct ReasonUi;
struct ReasonUiBuilder;
struct ReasonUiT;

struct ReasonCheckInOtherTag;
struct ReasonCheckInOtherTagBuilder;
struct ReasonCheckInOtherTagT;

struct ReasonCheckInOtherMachine;
struct ReasonCheckInOtherMachineBuilder;
struct ReasonCheckInOtherMachineT;

struct ReasonTimeout;
struct ReasonTimeoutBuilder;
struct ReasonTimeoutT;

struct ReasonSelfCheckout;
struct ReasonSelfCheckoutBuilder;
struct ReasonSelfCheckoutT;

struct MachineUsage;
struct MachineUsageBuilder;
struct MachineUsageT;

struct MachineUsageHistory;
struct MachineUsageHistoryBuilder;
struct MachineUsageHistoryT;

enum class CheckOutReason : uint8_t {
  NONE = 0,
  ui = 1,
  other_tag = 2,
  other_machine = 3,
  timeout = 4,
  self_checkout = 5,
  MIN = NONE,
  MAX = self_checkout
};

inline const CheckOutReason (&EnumValuesCheckOutReason())[6] {
  static const CheckOutReason values[] = {
    CheckOutReason::NONE,
    CheckOutReason::ui,
    CheckOutReason::other_tag,
    CheckOutReason::other_machine,
    CheckOutReason::timeout,
    CheckOutReason::self_checkout
  };
  return values;
}

inline const char * const *EnumNamesCheckOutReason() {
  static const char * const names[7] = {
    "NONE",
    "ui",
    "other_tag",
    "other_machine",
    "timeout",
    "self_checkout",
    nullptr
  };
  return names;
}

inline const char *EnumNameCheckOutReason(CheckOutReason e) {
  if (::flatbuffers::IsOutRange(e, CheckOutReason::NONE, CheckOutReason::self_checkout)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCheckOutReason()[index];
}

template<typename T> struct CheckOutReasonTraits {
  static const CheckOutReason enum_value = CheckOutReason::NONE;
};

template<> struct CheckOutReasonTraits<fbs::ReasonUi> {
  static const CheckOutReason enum_value = CheckOutReason::ui;
};

template<> struct CheckOutReasonTraits<fbs::ReasonCheckInOtherTag> {
  static const CheckOutReason enum_value = CheckOutReason::other_tag;
};

template<> struct CheckOutReasonTraits<fbs::ReasonCheckInOtherMachine> {
  static const CheckOutReason enum_value = CheckOutReason::other_machine;
};

template<> struct CheckOutReasonTraits<fbs::ReasonTimeout> {
  static const CheckOutReason enum_value = CheckOutReason::timeout;
};

template<> struct CheckOutReasonTraits<fbs::ReasonSelfCheckout> {
  static const CheckOutReason enum_value = CheckOutReason::self_checkout;
};

template<typename T> struct CheckOutReasonUnionTraits {
  static const CheckOutReason enum_value = CheckOutReason::NONE;
};

template<> struct CheckOutReasonUnionTraits<fbs::ReasonUiT> {
  static const CheckOutReason enum_value = CheckOutReason::ui;
};

template<> struct CheckOutReasonUnionTraits<fbs::ReasonCheckInOtherTagT> {
  static const CheckOutReason enum_value = CheckOutReason::other_tag;
};

template<> struct CheckOutReasonUnionTraits<fbs::ReasonCheckInOtherMachineT> {
  static const CheckOutReason enum_value = CheckOutReason::other_machine;
};

template<> struct CheckOutReasonUnionTraits<fbs::ReasonTimeoutT> {
  static const CheckOutReason enum_value = CheckOutReason::timeout;
};

template<> struct CheckOutReasonUnionTraits<fbs::ReasonSelfCheckoutT> {
  static const CheckOutReason enum_value = CheckOutReason::self_checkout;
};

struct CheckOutReasonUnion {
  CheckOutReason type;
  void *value;

  CheckOutReasonUnion() : type(CheckOutReason::NONE), value(nullptr) {}
  CheckOutReasonUnion(CheckOutReasonUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(CheckOutReason::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CheckOutReasonUnion(const CheckOutReasonUnion &);
  CheckOutReasonUnion &operator=(const CheckOutReasonUnion &u)
    { CheckOutReasonUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CheckOutReasonUnion &operator=(CheckOutReasonUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CheckOutReasonUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = CheckOutReasonUnionTraits<RT>::enum_value;
    if (type != CheckOutReason::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, CheckOutReason type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  fbs::ReasonUiT *Asui() {
    return type == CheckOutReason::ui ?
      reinterpret_cast<fbs::ReasonUiT *>(value) : nullptr;
  }
  const fbs::ReasonUiT *Asui() const {
    return type == CheckOutReason::ui ?
      reinterpret_cast<const fbs::ReasonUiT *>(value) : nullptr;
  }
  fbs::ReasonCheckInOtherTagT *Asother_tag() {
    return type == CheckOutReason::other_tag ?
      reinterpret_cast<fbs::ReasonCheckInOtherTagT *>(value) : nullptr;
  }
  const fbs::ReasonCheckInOtherTagT *Asother_tag() const {
    return type == CheckOutReason::other_tag ?
      reinterpret_cast<const fbs::ReasonCheckInOtherTagT *>(value) : nullptr;
  }
  fbs::ReasonCheckInOtherMachineT *Asother_machine() {
    return type == CheckOutReason::other_machine ?
      reinterpret_cast<fbs::ReasonCheckInOtherMachineT *>(value) : nullptr;
  }
  const fbs::ReasonCheckInOtherMachineT *Asother_machine() const {
    return type == CheckOutReason::other_machine ?
      reinterpret_cast<const fbs::ReasonCheckInOtherMachineT *>(value) : nullptr;
  }
  fbs::ReasonTimeoutT *Astimeout() {
    return type == CheckOutReason::timeout ?
      reinterpret_cast<fbs::ReasonTimeoutT *>(value) : nullptr;
  }
  const fbs::ReasonTimeoutT *Astimeout() const {
    return type == CheckOutReason::timeout ?
      reinterpret_cast<const fbs::ReasonTimeoutT *>(value) : nullptr;
  }
  fbs::ReasonSelfCheckoutT *Asself_checkout() {
    return type == CheckOutReason::self_checkout ?
      reinterpret_cast<fbs::ReasonSelfCheckoutT *>(value) : nullptr;
  }
  const fbs::ReasonSelfCheckoutT *Asself_checkout() const {
    return type == CheckOutReason::self_checkout ?
      reinterpret_cast<const fbs::ReasonSelfCheckoutT *>(value) : nullptr;
  }
};

bool VerifyCheckOutReason(::flatbuffers::Verifier &verifier, const void *obj, CheckOutReason type);
bool VerifyCheckOutReasonVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<CheckOutReason> *types);

struct ReasonUiT : public ::flatbuffers::NativeTable {
  typedef ReasonUi TableType;
};

struct ReasonUi FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReasonUiT NativeTableType;
  typedef ReasonUiBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReasonUiT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReasonUiT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReasonUi> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonUiT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReasonUiBuilder {
  typedef ReasonUi Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ReasonUiBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReasonUi> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReasonUi>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReasonUi> CreateReasonUi(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ReasonUiBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReasonUi::Traits {
  using type = ReasonUi;
  static auto constexpr Create = CreateReasonUi;
};

::flatbuffers::Offset<ReasonUi> CreateReasonUi(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonUiT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReasonCheckInOtherTagT : public ::flatbuffers::NativeTable {
  typedef ReasonCheckInOtherTag TableType;
  std::unique_ptr<fbs::TagUid> token_id{};
  std::string user_id{};
  ReasonCheckInOtherTagT() = default;
  ReasonCheckInOtherTagT(const ReasonCheckInOtherTagT &o);
  ReasonCheckInOtherTagT(ReasonCheckInOtherTagT&&) FLATBUFFERS_NOEXCEPT = default;
  ReasonCheckInOtherTagT &operator=(ReasonCheckInOtherTagT o) FLATBUFFERS_NOEXCEPT;
};

struct ReasonCheckInOtherTag FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReasonCheckInOtherTagT NativeTableType;
  typedef ReasonCheckInOtherTagBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN_ID = 4,
    VT_USER_ID = 6
  };
  const fbs::TagUid *token_id() const {
    return GetStruct<const fbs::TagUid *>(VT_TOKEN_ID);
  }
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fbs::TagUid>(verifier, VT_TOKEN_ID, 1) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           verifier.EndTable();
  }
  ReasonCheckInOtherTagT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReasonCheckInOtherTagT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReasonCheckInOtherTag> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonCheckInOtherTagT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReasonCheckInOtherTagBuilder {
  typedef ReasonCheckInOtherTag Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_token_id(const fbs::TagUid *token_id) {
    fbb_.AddStruct(ReasonCheckInOtherTag::VT_TOKEN_ID, token_id);
  }
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(ReasonCheckInOtherTag::VT_USER_ID, user_id);
  }
  explicit ReasonCheckInOtherTagBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReasonCheckInOtherTag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReasonCheckInOtherTag>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReasonCheckInOtherTag> CreateReasonCheckInOtherTag(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const fbs::TagUid *token_id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0) {
  ReasonCheckInOtherTagBuilder builder_(_fbb);
  builder_.add_user_id(user_id);
  builder_.add_token_id(token_id);
  return builder_.Finish();
}

struct ReasonCheckInOtherTag::Traits {
  using type = ReasonCheckInOtherTag;
  static auto constexpr Create = CreateReasonCheckInOtherTag;
};

inline ::flatbuffers::Offset<ReasonCheckInOtherTag> CreateReasonCheckInOtherTagDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const fbs::TagUid *token_id = nullptr,
    const char *user_id = nullptr) {
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  return fbs::CreateReasonCheckInOtherTag(
      _fbb,
      token_id,
      user_id__);
}

::flatbuffers::Offset<ReasonCheckInOtherTag> CreateReasonCheckInOtherTag(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonCheckInOtherTagT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReasonCheckInOtherMachineT : public ::flatbuffers::NativeTable {
  typedef ReasonCheckInOtherMachine TableType;
  std::string machine_id{};
};

struct ReasonCheckInOtherMachine FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReasonCheckInOtherMachineT NativeTableType;
  typedef ReasonCheckInOtherMachineBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MACHINE_ID = 4
  };
  const ::flatbuffers::String *machine_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MACHINE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MACHINE_ID) &&
           verifier.VerifyString(machine_id()) &&
           verifier.EndTable();
  }
  ReasonCheckInOtherMachineT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReasonCheckInOtherMachineT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReasonCheckInOtherMachine> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonCheckInOtherMachineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReasonCheckInOtherMachineBuilder {
  typedef ReasonCheckInOtherMachine Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_machine_id(::flatbuffers::Offset<::flatbuffers::String> machine_id) {
    fbb_.AddOffset(ReasonCheckInOtherMachine::VT_MACHINE_ID, machine_id);
  }
  explicit ReasonCheckInOtherMachineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReasonCheckInOtherMachine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReasonCheckInOtherMachine>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReasonCheckInOtherMachine> CreateReasonCheckInOtherMachine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> machine_id = 0) {
  ReasonCheckInOtherMachineBuilder builder_(_fbb);
  builder_.add_machine_id(machine_id);
  return builder_.Finish();
}

struct ReasonCheckInOtherMachine::Traits {
  using type = ReasonCheckInOtherMachine;
  static auto constexpr Create = CreateReasonCheckInOtherMachine;
};

inline ::flatbuffers::Offset<ReasonCheckInOtherMachine> CreateReasonCheckInOtherMachineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *machine_id = nullptr) {
  auto machine_id__ = machine_id ? _fbb.CreateString(machine_id) : 0;
  return fbs::CreateReasonCheckInOtherMachine(
      _fbb,
      machine_id__);
}

::flatbuffers::Offset<ReasonCheckInOtherMachine> CreateReasonCheckInOtherMachine(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonCheckInOtherMachineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReasonTimeoutT : public ::flatbuffers::NativeTable {
  typedef ReasonTimeout TableType;
};

struct ReasonTimeout FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReasonTimeoutT NativeTableType;
  typedef ReasonTimeoutBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReasonTimeoutT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReasonTimeoutT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReasonTimeout> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonTimeoutT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReasonTimeoutBuilder {
  typedef ReasonTimeout Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ReasonTimeoutBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReasonTimeout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReasonTimeout>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReasonTimeout> CreateReasonTimeout(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ReasonTimeoutBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReasonTimeout::Traits {
  using type = ReasonTimeout;
  static auto constexpr Create = CreateReasonTimeout;
};

::flatbuffers::Offset<ReasonTimeout> CreateReasonTimeout(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonTimeoutT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReasonSelfCheckoutT : public ::flatbuffers::NativeTable {
  typedef ReasonSelfCheckout TableType;
};

struct ReasonSelfCheckout FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReasonSelfCheckoutT NativeTableType;
  typedef ReasonSelfCheckoutBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReasonSelfCheckoutT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReasonSelfCheckoutT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReasonSelfCheckout> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonSelfCheckoutT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReasonSelfCheckoutBuilder {
  typedef ReasonSelfCheckout Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ReasonSelfCheckoutBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReasonSelfCheckout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReasonSelfCheckout>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReasonSelfCheckout> CreateReasonSelfCheckout(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ReasonSelfCheckoutBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReasonSelfCheckout::Traits {
  using type = ReasonSelfCheckout;
  static auto constexpr Create = CreateReasonSelfCheckout;
};

::flatbuffers::Offset<ReasonSelfCheckout> CreateReasonSelfCheckout(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonSelfCheckoutT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MachineUsageT : public ::flatbuffers::NativeTable {
  typedef MachineUsage TableType;
  std::string session_id{};
  int64_t check_in = 0;
  int64_t check_out = 0;
  fbs::CheckOutReasonUnion reason{};
};

struct MachineUsage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MachineUsageT NativeTableType;
  typedef MachineUsageBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4,
    VT_CHECK_IN = 6,
    VT_CHECK_OUT = 8,
    VT_REASON_TYPE = 10,
    VT_REASON = 12
  };
  const ::flatbuffers::String *session_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_ID);
  }
  int64_t check_in() const {
    return GetField<int64_t>(VT_CHECK_IN, 0);
  }
  int64_t check_out() const {
    return GetField<int64_t>(VT_CHECK_OUT, 0);
  }
  fbs::CheckOutReason reason_type() const {
    return static_cast<fbs::CheckOutReason>(GetField<uint8_t>(VT_REASON_TYPE, 0));
  }
  const void *reason() const {
    return GetPointer<const void *>(VT_REASON);
  }
  template<typename T> const T *reason_as() const;
  const fbs::ReasonUi *reason_as_ui() const {
    return reason_type() == fbs::CheckOutReason::ui ? static_cast<const fbs::ReasonUi *>(reason()) : nullptr;
  }
  const fbs::ReasonCheckInOtherTag *reason_as_other_tag() const {
    return reason_type() == fbs::CheckOutReason::other_tag ? static_cast<const fbs::ReasonCheckInOtherTag *>(reason()) : nullptr;
  }
  const fbs::ReasonCheckInOtherMachine *reason_as_other_machine() const {
    return reason_type() == fbs::CheckOutReason::other_machine ? static_cast<const fbs::ReasonCheckInOtherMachine *>(reason()) : nullptr;
  }
  const fbs::ReasonTimeout *reason_as_timeout() const {
    return reason_type() == fbs::CheckOutReason::timeout ? static_cast<const fbs::ReasonTimeout *>(reason()) : nullptr;
  }
  const fbs::ReasonSelfCheckout *reason_as_self_checkout() const {
    return reason_type() == fbs::CheckOutReason::self_checkout ? static_cast<const fbs::ReasonSelfCheckout *>(reason()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION_ID) &&
           verifier.VerifyString(session_id()) &&
           VerifyField<int64_t>(verifier, VT_CHECK_IN, 8) &&
           VerifyField<int64_t>(verifier, VT_CHECK_OUT, 8) &&
           VerifyField<uint8_t>(verifier, VT_REASON_TYPE, 1) &&
           VerifyOffset(verifier, VT_REASON) &&
           VerifyCheckOutReason(verifier, reason(), reason_type()) &&
           verifier.EndTable();
  }
  MachineUsageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MachineUsageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MachineUsage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MachineUsageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const fbs::ReasonUi *MachineUsage::reason_as<fbs::ReasonUi>() const {
  return reason_as_ui();
}

template<> inline const fbs::ReasonCheckInOtherTag *MachineUsage::reason_as<fbs::ReasonCheckInOtherTag>() const {
  return reason_as_other_tag();
}

template<> inline const fbs::ReasonCheckInOtherMachine *MachineUsage::reason_as<fbs::ReasonCheckInOtherMachine>() const {
  return reason_as_other_machine();
}

template<> inline const fbs::ReasonTimeout *MachineUsage::reason_as<fbs::ReasonTimeout>() const {
  return reason_as_timeout();
}

template<> inline const fbs::ReasonSelfCheckout *MachineUsage::reason_as<fbs::ReasonSelfCheckout>() const {
  return reason_as_self_checkout();
}

struct MachineUsageBuilder {
  typedef MachineUsage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(::flatbuffers::Offset<::flatbuffers::String> session_id) {
    fbb_.AddOffset(MachineUsage::VT_SESSION_ID, session_id);
  }
  void add_check_in(int64_t check_in) {
    fbb_.AddElement<int64_t>(MachineUsage::VT_CHECK_IN, check_in, 0);
  }
  void add_check_out(int64_t check_out) {
    fbb_.AddElement<int64_t>(MachineUsage::VT_CHECK_OUT, check_out, 0);
  }
  void add_reason_type(fbs::CheckOutReason reason_type) {
    fbb_.AddElement<uint8_t>(MachineUsage::VT_REASON_TYPE, static_cast<uint8_t>(reason_type), 0);
  }
  void add_reason(::flatbuffers::Offset<void> reason) {
    fbb_.AddOffset(MachineUsage::VT_REASON, reason);
  }
  explicit MachineUsageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MachineUsage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MachineUsage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MachineUsage> CreateMachineUsage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> session_id = 0,
    int64_t check_in = 0,
    int64_t check_out = 0,
    fbs::CheckOutReason reason_type = fbs::CheckOutReason::NONE,
    ::flatbuffers::Offset<void> reason = 0) {
  MachineUsageBuilder builder_(_fbb);
  builder_.add_check_out(check_out);
  builder_.add_check_in(check_in);
  builder_.add_reason(reason);
  builder_.add_session_id(session_id);
  builder_.add_reason_type(reason_type);
  return builder_.Finish();
}

struct MachineUsage::Traits {
  using type = MachineUsage;
  static auto constexpr Create = CreateMachineUsage;
};

inline ::flatbuffers::Offset<MachineUsage> CreateMachineUsageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_id = nullptr,
    int64_t check_in = 0,
    int64_t check_out = 0,
    fbs::CheckOutReason reason_type = fbs::CheckOutReason::NONE,
    ::flatbuffers::Offset<void> reason = 0) {
  auto session_id__ = session_id ? _fbb.CreateString(session_id) : 0;
  return fbs::CreateMachineUsage(
      _fbb,
      session_id__,
      check_in,
      check_out,
      reason_type,
      reason);
}

::flatbuffers::Offset<MachineUsage> CreateMachineUsage(::flatbuffers::FlatBufferBuilder &_fbb, const MachineUsageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MachineUsageHistoryT : public ::flatbuffers::NativeTable {
  typedef MachineUsageHistory TableType;
  std::string machine_id{};
  std::vector<std::unique_ptr<fbs::MachineUsageT>> records{};
  MachineUsageHistoryT() = default;
  MachineUsageHistoryT(const MachineUsageHistoryT &o);
  MachineUsageHistoryT(MachineUsageHistoryT&&) FLATBUFFERS_NOEXCEPT = default;
  MachineUsageHistoryT &operator=(MachineUsageHistoryT o) FLATBUFFERS_NOEXCEPT;
};

struct MachineUsageHistory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MachineUsageHistoryT NativeTableType;
  typedef MachineUsageHistoryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MACHINE_ID = 4,
    VT_RECORDS = 6
  };
  const ::flatbuffers::String *machine_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MACHINE_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::MachineUsage>> *records() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::MachineUsage>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MACHINE_ID) &&
           verifier.VerifyString(machine_id()) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
  MachineUsageHistoryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MachineUsageHistoryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MachineUsageHistory> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MachineUsageHistoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MachineUsageHistoryBuilder {
  typedef MachineUsageHistory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_machine_id(::flatbuffers::Offset<::flatbuffers::String> machine_id) {
    fbb_.AddOffset(MachineUsageHistory::VT_MACHINE_ID, machine_id);
  }
  void add_records(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::MachineUsage>>> records) {
    fbb_.AddOffset(MachineUsageHistory::VT_RECORDS, records);
  }
  explicit MachineUsageHistoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MachineUsageHistory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MachineUsageHistory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MachineUsageHistory> CreateMachineUsageHistory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> machine_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::MachineUsage>>> records = 0) {
  MachineUsageHistoryBuilder builder_(_fbb);
  builder_.add_records(records);
  builder_.add_machine_id(machine_id);
  return builder_.Finish();
}

struct MachineUsageHistory::Traits {
  using type = MachineUsageHistory;
  static auto constexpr Create = CreateMachineUsageHistory;
};

inline ::flatbuffers::Offset<MachineUsageHistory> CreateMachineUsageHistoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *machine_id = nullptr,
    const std::vector<::flatbuffers::Offset<fbs::MachineUsage>> *records = nullptr) {
  auto machine_id__ = machine_id ? _fbb.CreateString(machine_id) : 0;
  auto records__ = records ? _fbb.CreateVector<::flatbuffers::Offset<fbs::MachineUsage>>(*records) : 0;
  return fbs::CreateMachineUsageHistory(
      _fbb,
      machine_id__,
      records__);
}

::flatbuffers::Offset<MachineUsageHistory> CreateMachineUsageHistory(::flatbuffers::FlatBufferBuilder &_fbb, const MachineUsageHistoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ReasonUiT *ReasonUi::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ReasonUiT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReasonUi::UnPackTo(ReasonUiT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ReasonUi> ReasonUi::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonUiT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReasonUi(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReasonUi> CreateReasonUi(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonUiT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReasonUiT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return fbs::CreateReasonUi(
      _fbb);
}

inline ReasonCheckInOtherTagT::ReasonCheckInOtherTagT(const ReasonCheckInOtherTagT &o)
      : token_id((o.token_id) ? new fbs::TagUid(*o.token_id) : nullptr),
        user_id(o.user_id) {
}

inline ReasonCheckInOtherTagT &ReasonCheckInOtherTagT::operator=(ReasonCheckInOtherTagT o) FLATBUFFERS_NOEXCEPT {
  std::swap(token_id, o.token_id);
  std::swap(user_id, o.user_id);
  return *this;
}

inline ReasonCheckInOtherTagT *ReasonCheckInOtherTag::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ReasonCheckInOtherTagT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReasonCheckInOtherTag::UnPackTo(ReasonCheckInOtherTagT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = token_id(); if (_e) _o->token_id = std::unique_ptr<fbs::TagUid>(new fbs::TagUid(*_e)); }
  { auto _e = user_id(); if (_e) _o->user_id = _e->str(); }
}

inline ::flatbuffers::Offset<ReasonCheckInOtherTag> ReasonCheckInOtherTag::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonCheckInOtherTagT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReasonCheckInOtherTag(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReasonCheckInOtherTag> CreateReasonCheckInOtherTag(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonCheckInOtherTagT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReasonCheckInOtherTagT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _token_id = _o->token_id ? _o->token_id.get() : nullptr;
  auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
  return fbs::CreateReasonCheckInOtherTag(
      _fbb,
      _token_id,
      _user_id);
}

inline ReasonCheckInOtherMachineT *ReasonCheckInOtherMachine::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ReasonCheckInOtherMachineT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReasonCheckInOtherMachine::UnPackTo(ReasonCheckInOtherMachineT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = machine_id(); if (_e) _o->machine_id = _e->str(); }
}

inline ::flatbuffers::Offset<ReasonCheckInOtherMachine> ReasonCheckInOtherMachine::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonCheckInOtherMachineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReasonCheckInOtherMachine(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReasonCheckInOtherMachine> CreateReasonCheckInOtherMachine(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonCheckInOtherMachineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReasonCheckInOtherMachineT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _machine_id = _o->machine_id.empty() ? 0 : _fbb.CreateString(_o->machine_id);
  return fbs::CreateReasonCheckInOtherMachine(
      _fbb,
      _machine_id);
}

inline ReasonTimeoutT *ReasonTimeout::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ReasonTimeoutT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReasonTimeout::UnPackTo(ReasonTimeoutT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ReasonTimeout> ReasonTimeout::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonTimeoutT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReasonTimeout(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReasonTimeout> CreateReasonTimeout(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonTimeoutT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReasonTimeoutT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return fbs::CreateReasonTimeout(
      _fbb);
}

inline ReasonSelfCheckoutT *ReasonSelfCheckout::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ReasonSelfCheckoutT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReasonSelfCheckout::UnPackTo(ReasonSelfCheckoutT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<ReasonSelfCheckout> ReasonSelfCheckout::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonSelfCheckoutT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReasonSelfCheckout(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReasonSelfCheckout> CreateReasonSelfCheckout(::flatbuffers::FlatBufferBuilder &_fbb, const ReasonSelfCheckoutT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReasonSelfCheckoutT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return fbs::CreateReasonSelfCheckout(
      _fbb);
}

inline MachineUsageT *MachineUsage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MachineUsageT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MachineUsage::UnPackTo(MachineUsageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); if (_e) _o->session_id = _e->str(); }
  { auto _e = check_in(); _o->check_in = _e; }
  { auto _e = check_out(); _o->check_out = _e; }
  { auto _e = reason_type(); _o->reason.type = _e; }
  { auto _e = reason(); if (_e) _o->reason.value = fbs::CheckOutReasonUnion::UnPack(_e, reason_type(), _resolver); }
}

inline ::flatbuffers::Offset<MachineUsage> MachineUsage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MachineUsageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMachineUsage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MachineUsage> CreateMachineUsage(::flatbuffers::FlatBufferBuilder &_fbb, const MachineUsageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MachineUsageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _session_id = _o->session_id.empty() ? 0 : _fbb.CreateString(_o->session_id);
  auto _check_in = _o->check_in;
  auto _check_out = _o->check_out;
  auto _reason_type = _o->reason.type;
  auto _reason = _o->reason.Pack(_fbb);
  return fbs::CreateMachineUsage(
      _fbb,
      _session_id,
      _check_in,
      _check_out,
      _reason_type,
      _reason);
}

inline MachineUsageHistoryT::MachineUsageHistoryT(const MachineUsageHistoryT &o)
      : machine_id(o.machine_id) {
  records.reserve(o.records.size());
  for (const auto &records_ : o.records) { records.emplace_back((records_) ? new fbs::MachineUsageT(*records_) : nullptr); }
}

inline MachineUsageHistoryT &MachineUsageHistoryT::operator=(MachineUsageHistoryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(machine_id, o.machine_id);
  std::swap(records, o.records);
  return *this;
}

inline MachineUsageHistoryT *MachineUsageHistory::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MachineUsageHistoryT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MachineUsageHistory::UnPackTo(MachineUsageHistoryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = machine_id(); if (_e) _o->machine_id = _e->str(); }
  { auto _e = records(); if (_e) { _o->records.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->records[_i]) { _e->Get(_i)->UnPackTo(_o->records[_i].get(), _resolver); } else { _o->records[_i] = std::unique_ptr<fbs::MachineUsageT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->records.resize(0); } }
}

inline ::flatbuffers::Offset<MachineUsageHistory> MachineUsageHistory::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MachineUsageHistoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMachineUsageHistory(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MachineUsageHistory> CreateMachineUsageHistory(::flatbuffers::FlatBufferBuilder &_fbb, const MachineUsageHistoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MachineUsageHistoryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _machine_id = _o->machine_id.empty() ? 0 : _fbb.CreateString(_o->machine_id);
  auto _records = _o->records.size() ? _fbb.CreateVector<::flatbuffers::Offset<fbs::MachineUsage>> (_o->records.size(), [](size_t i, _VectorArgs *__va) { return CreateMachineUsage(*__va->__fbb, __va->__o->records[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fbs::CreateMachineUsageHistory(
      _fbb,
      _machine_id,
      _records);
}

inline bool VerifyCheckOutReason(::flatbuffers::Verifier &verifier, const void *obj, CheckOutReason type) {
  switch (type) {
    case CheckOutReason::NONE: {
      return true;
    }
    case CheckOutReason::ui: {
      auto ptr = reinterpret_cast<const fbs::ReasonUi *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CheckOutReason::other_tag: {
      auto ptr = reinterpret_cast<const fbs::ReasonCheckInOtherTag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CheckOutReason::other_machine: {
      auto ptr = reinterpret_cast<const fbs::ReasonCheckInOtherMachine *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CheckOutReason::timeout: {
      auto ptr = reinterpret_cast<const fbs::ReasonTimeout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CheckOutReason::self_checkout: {
      auto ptr = reinterpret_cast<const fbs::ReasonSelfCheckout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCheckOutReasonVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<CheckOutReason> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCheckOutReason(
        verifier,  values->Get(i), types->GetEnum<CheckOutReason>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CheckOutReasonUnion::UnPack(const void *obj, CheckOutReason type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case CheckOutReason::ui: {
      auto ptr = reinterpret_cast<const fbs::ReasonUi *>(obj);
      return ptr->UnPack(resolver);
    }
    case CheckOutReason::other_tag: {
      auto ptr = reinterpret_cast<const fbs::ReasonCheckInOtherTag *>(obj);
      return ptr->UnPack(resolver);
    }
    case CheckOutReason::other_machine: {
      auto ptr = reinterpret_cast<const fbs::ReasonCheckInOtherMachine *>(obj);
      return ptr->UnPack(resolver);
    }
    case CheckOutReason::timeout: {
      auto ptr = reinterpret_cast<const fbs::ReasonTimeout *>(obj);
      return ptr->UnPack(resolver);
    }
    case CheckOutReason::self_checkout: {
      auto ptr = reinterpret_cast<const fbs::ReasonSelfCheckout *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> CheckOutReasonUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case CheckOutReason::ui: {
      auto ptr = reinterpret_cast<const fbs::ReasonUiT *>(value);
      return CreateReasonUi(_fbb, ptr, _rehasher).Union();
    }
    case CheckOutReason::other_tag: {
      auto ptr = reinterpret_cast<const fbs::ReasonCheckInOtherTagT *>(value);
      return CreateReasonCheckInOtherTag(_fbb, ptr, _rehasher).Union();
    }
    case CheckOutReason::other_machine: {
      auto ptr = reinterpret_cast<const fbs::ReasonCheckInOtherMachineT *>(value);
      return CreateReasonCheckInOtherMachine(_fbb, ptr, _rehasher).Union();
    }
    case CheckOutReason::timeout: {
      auto ptr = reinterpret_cast<const fbs::ReasonTimeoutT *>(value);
      return CreateReasonTimeout(_fbb, ptr, _rehasher).Union();
    }
    case CheckOutReason::self_checkout: {
      auto ptr = reinterpret_cast<const fbs::ReasonSelfCheckoutT *>(value);
      return CreateReasonSelfCheckout(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline CheckOutReasonUnion::CheckOutReasonUnion(const CheckOutReasonUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case CheckOutReason::ui: {
      value = new fbs::ReasonUiT(*reinterpret_cast<fbs::ReasonUiT *>(u.value));
      break;
    }
    case CheckOutReason::other_tag: {
      value = new fbs::ReasonCheckInOtherTagT(*reinterpret_cast<fbs::ReasonCheckInOtherTagT *>(u.value));
      break;
    }
    case CheckOutReason::other_machine: {
      value = new fbs::ReasonCheckInOtherMachineT(*reinterpret_cast<fbs::ReasonCheckInOtherMachineT *>(u.value));
      break;
    }
    case CheckOutReason::timeout: {
      value = new fbs::ReasonTimeoutT(*reinterpret_cast<fbs::ReasonTimeoutT *>(u.value));
      break;
    }
    case CheckOutReason::self_checkout: {
      value = new fbs::ReasonSelfCheckoutT(*reinterpret_cast<fbs::ReasonSelfCheckoutT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CheckOutReasonUnion::Reset() {
  switch (type) {
    case CheckOutReason::ui: {
      auto ptr = reinterpret_cast<fbs::ReasonUiT *>(value);
      delete ptr;
      break;
    }
    case CheckOutReason::other_tag: {
      auto ptr = reinterpret_cast<fbs::ReasonCheckInOtherTagT *>(value);
      delete ptr;
      break;
    }
    case CheckOutReason::other_machine: {
      auto ptr = reinterpret_cast<fbs::ReasonCheckInOtherMachineT *>(value);
      delete ptr;
      break;
    }
    case CheckOutReason::timeout: {
      auto ptr = reinterpret_cast<fbs::ReasonTimeoutT *>(value);
      delete ptr;
      break;
    }
    case CheckOutReason::self_checkout: {
      auto ptr = reinterpret_cast<fbs::ReasonSelfCheckoutT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = CheckOutReason::NONE;
}

inline const fbs::MachineUsageHistory *GetMachineUsageHistory(const void *buf) {
  return ::flatbuffers::GetRoot<fbs::MachineUsageHistory>(buf);
}

inline const fbs::MachineUsageHistory *GetSizePrefixedMachineUsageHistory(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fbs::MachineUsageHistory>(buf);
}

inline bool VerifyMachineUsageHistoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fbs::MachineUsageHistory>(nullptr);
}

inline bool VerifySizePrefixedMachineUsageHistoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fbs::MachineUsageHistory>(nullptr);
}

inline void FinishMachineUsageHistoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::MachineUsageHistory> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMachineUsageHistoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::MachineUsageHistory> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fbs::MachineUsageHistoryT> UnPackMachineUsageHistory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fbs::MachineUsageHistoryT>(GetMachineUsageHistory(buf)->UnPack(res));
}

inline std::unique_ptr<fbs::MachineUsageHistoryT> UnPackSizePrefixedMachineUsageHistory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fbs::MachineUsageHistoryT>(GetSizePrefixedMachineUsageHistory(buf)->UnPack(res));
}

}  // namespace fbs

#endif  // FLATBUFFERS_GENERATED_MACHINEUSAGE_FBS_H_
