// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LEDGERTERMINALCONFIG_FBS_H_
#define FLATBUFFERS_GENERATED_LEDGERTERMINALCONFIG_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "common.h"

namespace fbs {

struct MachineControlRelais;
struct MachineControlRelaisBuilder;
struct MachineControlRelaisT;

struct Machine;
struct MachineBuilder;
struct MachineT;

struct DeviceConfig;
struct DeviceConfigBuilder;
struct DeviceConfigT;

enum class HwRevision : int8_t {
  Unspecified = 0,
  Breadboard = 1,
  Prototype = 2,
  MIN = Unspecified,
  MAX = Prototype
};

inline const HwRevision (&EnumValuesHwRevision())[3] {
  static const HwRevision values[] = {
    HwRevision::Unspecified,
    HwRevision::Breadboard,
    HwRevision::Prototype
  };
  return values;
}

inline const char * const *EnumNamesHwRevision() {
  static const char * const names[4] = {
    "Unspecified",
    "Breadboard",
    "Prototype",
    nullptr
  };
  return names;
}

inline const char *EnumNameHwRevision(HwRevision e) {
  if (::flatbuffers::IsOutRange(e, HwRevision::Unspecified, HwRevision::Prototype)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHwRevision()[index];
}

enum class MachineControl : uint8_t {
  NONE = 0,
  relais = 1,
  MIN = NONE,
  MAX = relais
};

inline const MachineControl (&EnumValuesMachineControl())[2] {
  static const MachineControl values[] = {
    MachineControl::NONE,
    MachineControl::relais
  };
  return values;
}

inline const char * const *EnumNamesMachineControl() {
  static const char * const names[3] = {
    "NONE",
    "relais",
    nullptr
  };
  return names;
}

inline const char *EnumNameMachineControl(MachineControl e) {
  if (::flatbuffers::IsOutRange(e, MachineControl::NONE, MachineControl::relais)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMachineControl()[index];
}

template<typename T> struct MachineControlTraits {
  static const MachineControl enum_value = MachineControl::NONE;
};

template<> struct MachineControlTraits<fbs::MachineControlRelais> {
  static const MachineControl enum_value = MachineControl::relais;
};

template<typename T> struct MachineControlUnionTraits {
  static const MachineControl enum_value = MachineControl::NONE;
};

template<> struct MachineControlUnionTraits<fbs::MachineControlRelaisT> {
  static const MachineControl enum_value = MachineControl::relais;
};

struct MachineControlUnion {
  MachineControl type;
  void *value;

  MachineControlUnion() : type(MachineControl::NONE), value(nullptr) {}
  MachineControlUnion(MachineControlUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MachineControl::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MachineControlUnion(const MachineControlUnion &);
  MachineControlUnion &operator=(const MachineControlUnion &u)
    { MachineControlUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MachineControlUnion &operator=(MachineControlUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MachineControlUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = MachineControlUnionTraits<RT>::enum_value;
    if (type != MachineControl::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, MachineControl type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  fbs::MachineControlRelaisT *Asrelais() {
    return type == MachineControl::relais ?
      reinterpret_cast<fbs::MachineControlRelaisT *>(value) : nullptr;
  }
  const fbs::MachineControlRelaisT *Asrelais() const {
    return type == MachineControl::relais ?
      reinterpret_cast<const fbs::MachineControlRelaisT *>(value) : nullptr;
  }
};

bool VerifyMachineControl(::flatbuffers::Verifier &verifier, const void *obj, MachineControl type);
bool VerifyMachineControlVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<MachineControl> *types);

struct MachineControlRelaisT : public ::flatbuffers::NativeTable {
  typedef MachineControlRelais TableType;
};

struct MachineControlRelais FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MachineControlRelaisT NativeTableType;
  typedef MachineControlRelaisBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MachineControlRelaisT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MachineControlRelaisT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MachineControlRelais> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MachineControlRelaisT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MachineControlRelaisBuilder {
  typedef MachineControlRelais Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit MachineControlRelaisBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MachineControlRelais> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MachineControlRelais>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MachineControlRelais> CreateMachineControlRelais(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  MachineControlRelaisBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MachineControlRelais::Traits {
  using type = MachineControlRelais;
  static auto constexpr Create = CreateMachineControlRelais;
};

::flatbuffers::Offset<MachineControlRelais> CreateMachineControlRelais(::flatbuffers::FlatBufferBuilder &_fbb, const MachineControlRelaisT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MachineT : public ::flatbuffers::NativeTable {
  typedef Machine TableType;
  std::string id{};
  std::string label{};
  std::vector<std::string> required_permissions{};
  fbs::MachineControlUnion control{};
};

struct Machine FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MachineT NativeTableType;
  typedef MachineBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LABEL = 6,
    VT_REQUIRED_PERMISSIONS = 8,
    VT_CONTROL_TYPE = 10,
    VT_CONTROL = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *required_permissions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_REQUIRED_PERMISSIONS);
  }
  fbs::MachineControl control_type() const {
    return static_cast<fbs::MachineControl>(GetField<uint8_t>(VT_CONTROL_TYPE, 0));
  }
  const void *control() const {
    return GetPointer<const void *>(VT_CONTROL);
  }
  template<typename T> const T *control_as() const;
  const fbs::MachineControlRelais *control_as_relais() const {
    return control_type() == fbs::MachineControl::relais ? static_cast<const fbs::MachineControlRelais *>(control()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_REQUIRED_PERMISSIONS) &&
           verifier.VerifyVector(required_permissions()) &&
           verifier.VerifyVectorOfStrings(required_permissions()) &&
           VerifyField<uint8_t>(verifier, VT_CONTROL_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTROL) &&
           VerifyMachineControl(verifier, control(), control_type()) &&
           verifier.EndTable();
  }
  MachineT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MachineT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Machine> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MachineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const fbs::MachineControlRelais *Machine::control_as<fbs::MachineControlRelais>() const {
  return control_as_relais();
}

struct MachineBuilder {
  typedef Machine Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Machine::VT_ID, id);
  }
  void add_label(::flatbuffers::Offset<::flatbuffers::String> label) {
    fbb_.AddOffset(Machine::VT_LABEL, label);
  }
  void add_required_permissions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> required_permissions) {
    fbb_.AddOffset(Machine::VT_REQUIRED_PERMISSIONS, required_permissions);
  }
  void add_control_type(fbs::MachineControl control_type) {
    fbb_.AddElement<uint8_t>(Machine::VT_CONTROL_TYPE, static_cast<uint8_t>(control_type), 0);
  }
  void add_control(::flatbuffers::Offset<void> control) {
    fbb_.AddOffset(Machine::VT_CONTROL, control);
  }
  explicit MachineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Machine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Machine>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Machine> CreateMachine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> required_permissions = 0,
    fbs::MachineControl control_type = fbs::MachineControl::NONE,
    ::flatbuffers::Offset<void> control = 0) {
  MachineBuilder builder_(_fbb);
  builder_.add_control(control);
  builder_.add_required_permissions(required_permissions);
  builder_.add_label(label);
  builder_.add_id(id);
  builder_.add_control_type(control_type);
  return builder_.Finish();
}

struct Machine::Traits {
  using type = Machine;
  static auto constexpr Create = CreateMachine;
};

inline ::flatbuffers::Offset<Machine> CreateMachineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *label = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *required_permissions = nullptr,
    fbs::MachineControl control_type = fbs::MachineControl::NONE,
    ::flatbuffers::Offset<void> control = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto required_permissions__ = required_permissions ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*required_permissions) : 0;
  return fbs::CreateMachine(
      _fbb,
      id__,
      label__,
      required_permissions__,
      control_type,
      control);
}

::flatbuffers::Offset<Machine> CreateMachine(::flatbuffers::FlatBufferBuilder &_fbb, const MachineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeviceConfigT : public ::flatbuffers::NativeTable {
  typedef DeviceConfig TableType;
  fbs::HwRevision hw_revision = fbs::HwRevision::Unspecified;
  std::vector<std::unique_ptr<fbs::MachineT>> machines{};
  DeviceConfigT() = default;
  DeviceConfigT(const DeviceConfigT &o);
  DeviceConfigT(DeviceConfigT&&) FLATBUFFERS_NOEXCEPT = default;
  DeviceConfigT &operator=(DeviceConfigT o) FLATBUFFERS_NOEXCEPT;
};

struct DeviceConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeviceConfigT NativeTableType;
  typedef DeviceConfigBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HW_REVISION = 4,
    VT_MACHINES = 6
  };
  fbs::HwRevision hw_revision() const {
    return static_cast<fbs::HwRevision>(GetField<int8_t>(VT_HW_REVISION, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::Machine>> *machines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::Machine>> *>(VT_MACHINES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_HW_REVISION, 1) &&
           VerifyOffset(verifier, VT_MACHINES) &&
           verifier.VerifyVector(machines()) &&
           verifier.VerifyVectorOfTables(machines()) &&
           verifier.EndTable();
  }
  DeviceConfigT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeviceConfigT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DeviceConfig> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DeviceConfigT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeviceConfigBuilder {
  typedef DeviceConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hw_revision(fbs::HwRevision hw_revision) {
    fbb_.AddElement<int8_t>(DeviceConfig::VT_HW_REVISION, static_cast<int8_t>(hw_revision), 0);
  }
  void add_machines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::Machine>>> machines) {
    fbb_.AddOffset(DeviceConfig::VT_MACHINES, machines);
  }
  explicit DeviceConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeviceConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeviceConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeviceConfig> CreateDeviceConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::HwRevision hw_revision = fbs::HwRevision::Unspecified,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::Machine>>> machines = 0) {
  DeviceConfigBuilder builder_(_fbb);
  builder_.add_machines(machines);
  builder_.add_hw_revision(hw_revision);
  return builder_.Finish();
}

struct DeviceConfig::Traits {
  using type = DeviceConfig;
  static auto constexpr Create = CreateDeviceConfig;
};

inline ::flatbuffers::Offset<DeviceConfig> CreateDeviceConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::HwRevision hw_revision = fbs::HwRevision::Unspecified,
    const std::vector<::flatbuffers::Offset<fbs::Machine>> *machines = nullptr) {
  auto machines__ = machines ? _fbb.CreateVector<::flatbuffers::Offset<fbs::Machine>>(*machines) : 0;
  return fbs::CreateDeviceConfig(
      _fbb,
      hw_revision,
      machines__);
}

::flatbuffers::Offset<DeviceConfig> CreateDeviceConfig(::flatbuffers::FlatBufferBuilder &_fbb, const DeviceConfigT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MachineControlRelaisT *MachineControlRelais::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MachineControlRelaisT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MachineControlRelais::UnPackTo(MachineControlRelaisT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<MachineControlRelais> MachineControlRelais::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MachineControlRelaisT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMachineControlRelais(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MachineControlRelais> CreateMachineControlRelais(::flatbuffers::FlatBufferBuilder &_fbb, const MachineControlRelaisT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MachineControlRelaisT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return fbs::CreateMachineControlRelais(
      _fbb);
}

inline MachineT *Machine::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<MachineT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Machine::UnPackTo(MachineT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = label(); if (_e) _o->label = _e->str(); }
  { auto _e = required_permissions(); if (_e) { _o->required_permissions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->required_permissions[_i] = _e->Get(_i)->str(); } } else { _o->required_permissions.resize(0); } }
  { auto _e = control_type(); _o->control.type = _e; }
  { auto _e = control(); if (_e) _o->control.value = fbs::MachineControlUnion::UnPack(_e, control_type(), _resolver); }
}

inline ::flatbuffers::Offset<Machine> Machine::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MachineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMachine(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Machine> CreateMachine(::flatbuffers::FlatBufferBuilder &_fbb, const MachineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MachineT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _label = _o->label.empty() ? 0 : _fbb.CreateString(_o->label);
  auto _required_permissions = _o->required_permissions.size() ? _fbb.CreateVectorOfStrings(_o->required_permissions) : 0;
  auto _control_type = _o->control.type;
  auto _control = _o->control.Pack(_fbb);
  return fbs::CreateMachine(
      _fbb,
      _id,
      _label,
      _required_permissions,
      _control_type,
      _control);
}

inline DeviceConfigT::DeviceConfigT(const DeviceConfigT &o)
      : hw_revision(o.hw_revision) {
  machines.reserve(o.machines.size());
  for (const auto &machines_ : o.machines) { machines.emplace_back((machines_) ? new fbs::MachineT(*machines_) : nullptr); }
}

inline DeviceConfigT &DeviceConfigT::operator=(DeviceConfigT o) FLATBUFFERS_NOEXCEPT {
  std::swap(hw_revision, o.hw_revision);
  std::swap(machines, o.machines);
  return *this;
}

inline DeviceConfigT *DeviceConfig::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<DeviceConfigT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeviceConfig::UnPackTo(DeviceConfigT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hw_revision(); _o->hw_revision = _e; }
  { auto _e = machines(); if (_e) { _o->machines.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->machines[_i]) { _e->Get(_i)->UnPackTo(_o->machines[_i].get(), _resolver); } else { _o->machines[_i] = std::unique_ptr<fbs::MachineT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->machines.resize(0); } }
}

inline ::flatbuffers::Offset<DeviceConfig> DeviceConfig::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DeviceConfigT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeviceConfig(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DeviceConfig> CreateDeviceConfig(::flatbuffers::FlatBufferBuilder &_fbb, const DeviceConfigT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DeviceConfigT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hw_revision = _o->hw_revision;
  auto _machines = _o->machines.size() ? _fbb.CreateVector<::flatbuffers::Offset<fbs::Machine>> (_o->machines.size(), [](size_t i, _VectorArgs *__va) { return CreateMachine(*__va->__fbb, __va->__o->machines[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fbs::CreateDeviceConfig(
      _fbb,
      _hw_revision,
      _machines);
}

inline bool VerifyMachineControl(::flatbuffers::Verifier &verifier, const void *obj, MachineControl type) {
  switch (type) {
    case MachineControl::NONE: {
      return true;
    }
    case MachineControl::relais: {
      auto ptr = reinterpret_cast<const fbs::MachineControlRelais *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMachineControlVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<MachineControl> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMachineControl(
        verifier,  values->Get(i), types->GetEnum<MachineControl>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MachineControlUnion::UnPack(const void *obj, MachineControl type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case MachineControl::relais: {
      auto ptr = reinterpret_cast<const fbs::MachineControlRelais *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> MachineControlUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case MachineControl::relais: {
      auto ptr = reinterpret_cast<const fbs::MachineControlRelaisT *>(value);
      return CreateMachineControlRelais(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MachineControlUnion::MachineControlUnion(const MachineControlUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case MachineControl::relais: {
      value = new fbs::MachineControlRelaisT(*reinterpret_cast<fbs::MachineControlRelaisT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MachineControlUnion::Reset() {
  switch (type) {
    case MachineControl::relais: {
      auto ptr = reinterpret_cast<fbs::MachineControlRelaisT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MachineControl::NONE;
}

}  // namespace fbs

#endif  // FLATBUFFERS_GENERATED_LEDGERTERMINALCONFIG_FBS_H_
