// Copyright Offene Werkstatt WÃ¤denswil
// SPDX-License-Identifier: MIT

#pragma once

/// @file proto_serializer.h
/// @brief Serializer for nanopb generated messages.
///
/// This serializer works with messages generated by nanopb_proto_library.
/// Each proto generates a struct (e.g., maco_proto_particle_DeviceConfig)
/// with corresponding _fields descriptor and _init_zero initializer.
///
/// To use, specialize NanopbFields<T> for your message type:
/// @code
/// #include "particle/device_config.pb.h"
///
/// template <>
/// struct pb::cloud::NanopbFields<maco_proto_particle_DeviceConfig> {
///   static const pb_msgdesc_t* fields() {
///     return maco_proto_particle_DeviceConfig_fields;
///   }
///   static maco_proto_particle_DeviceConfig init_zero() {
///     return maco_proto_particle_DeviceConfig_init_zero;
///   }
/// };
///
/// // Then use ProtoSerializer:
/// maco_proto_particle_DeviceConfig msg = {};
/// std::array<std::byte, 256> buffer;
///
/// auto size = ProtoSerializer<maco_proto_particle_DeviceConfig>
///     ::Serialize(msg, buffer);
/// auto decoded = ProtoSerializer<maco_proto_particle_DeviceConfig>
///     ::Deserialize(pw::ConstByteSpan(buffer.data(), size.value()));
/// @endcode

#include "pb_decode.h"
#include "pb_encode.h"

#include "pb_cloud/serializer.h"
#include "pb_cloud/types.h"
#include "pw_bytes/span.h"
#include "pw_result/result.h"

namespace pb::cloud {

/// Traits template for nanopb message types. Must be specialized per type.
///
/// Specializations must provide:
/// - static const pb_msgdesc_t* fields() - field descriptor
/// - static T init_zero() - zero-initialized message
template <typename T>
struct NanopbFields;  // Primary template (undefined - must specialize)

/// Serializer for nanopb generated messages.
///
/// @tparam T The nanopb message struct type
///           Must have NanopbFields<T> specialized.
template <typename T>
struct ProtoSerializer {
  /// Serialize message to buffer.
  ///
  /// @param value Message to serialize
  /// @param buffer Output buffer (must be large enough for encoded message)
  /// @return Number of bytes written, or error
  static pw::Result<size_t> Serialize(const T& value, pw::ByteSpan buffer) {
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
    pb_ostream_t stream = pb_ostream_from_buffer(
        reinterpret_cast<pb_byte_t*>(buffer.data()), buffer.size());
    if (!pb_encode(&stream, NanopbFields<T>::fields(), &value)) {
      return pw::Status::Internal();
    }
    return stream.bytes_written;
  }

  /// Deserialize bytes to message.
  ///
  /// @param data Encoded proto bytes
  /// @return Decoded message, or error
  static pw::Result<T> Deserialize(pw::ConstByteSpan data) {
    T msg = NanopbFields<T>::init_zero();
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
    pb_istream_t stream = pb_istream_from_buffer(
        reinterpret_cast<const pb_byte_t*>(data.data()), data.size());
    if (!pb_decode(&stream, NanopbFields<T>::fields(), &msg)) {
      return pw::Status::DataLoss();
    }
    return msg;
  }

  /// Content type for protobuf serialization.
  static constexpr ContentType kContentType = ContentType::kStructured;
};

}  // namespace pb::cloud
