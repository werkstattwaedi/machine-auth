// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: gateway/gateway_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "maco.gateway";

/** Request to forward to Firebase. */
export interface ForwardRequest {
  /** Firebase endpoint path (e.g., "/api/startSession") */
  endpoint: string;
  /** Request payload (serialized protobuf, opaque to gateway) */
  payload: Uint8Array;
  /** Optional request ID for correlation */
  requestId: number;
}

/** Response from Firebase forwarding. */
export interface ForwardResponse {
  /** True if Firebase returned a successful response */
  success: boolean;
  /** Response payload (serialized protobuf, opaque to gateway) */
  payload: Uint8Array;
  /** HTTP status code from Firebase (0 if not applicable) */
  httpStatus: number;
  /** Error message if success is false */
  error: string;
  /** Request ID for correlation (echoed from request) */
  requestId: number;
}

/** Log entry to persist on gateway. */
export interface LogEntry {
  /** Timestamp (milliseconds since epoch) */
  timestampMs: bigint;
  /** Log level */
  level: LogEntry_Level;
  /** Log module/component name */
  module: string;
  /** Log message */
  message: string;
  /** Optional structured data (JSON) */
  data: string;
}

/** Log level */
export enum LogEntry_Level {
  LEVEL_UNSPECIFIED = 0,
  DEBUG = 1,
  INFO = 2,
  WARN = 3,
  ERROR = 4,
  UNRECOGNIZED = -1,
}

/** Response to log persistence. */
export interface LogResponse {
  /** True if log was persisted successfully */
  success: boolean;
  /** Number of pending logs on gateway */
  pendingCount: number;
}

/** Ping request. */
export interface PingRequest {
  /** Client timestamp (milliseconds since epoch) */
  clientTimestampMs: bigint;
}

/** Ping response. */
export interface PingResponse {
  /** Gateway timestamp (milliseconds since epoch) */
  gatewayTimestampMs: bigint;
  /** Echo of client timestamp */
  clientTimestampMs: bigint;
}

function createBaseForwardRequest(): ForwardRequest {
  return { endpoint: "", payload: new Uint8Array(0), requestId: 0 };
}

export const ForwardRequest: MessageFns<ForwardRequest> = {
  encode(message: ForwardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== "") {
      writer.uint32(10).string(message.endpoint);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    if (message.requestId !== 0) {
      writer.uint32(24).uint32(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.requestId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ForwardRequest>): ForwardRequest {
    return ForwardRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForwardRequest>): ForwardRequest {
    const message = createBaseForwardRequest();
    message.endpoint = object.endpoint ?? "";
    message.payload = object.payload ?? new Uint8Array(0);
    message.requestId = object.requestId ?? 0;
    return message;
  },
};

function createBaseForwardResponse(): ForwardResponse {
  return { success: false, payload: new Uint8Array(0), httpStatus: 0, error: "", requestId: 0 };
}

export const ForwardResponse: MessageFns<ForwardResponse> = {
  encode(message: ForwardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    if (message.httpStatus !== 0) {
      writer.uint32(24).uint32(message.httpStatus);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    if (message.requestId !== 0) {
      writer.uint32(40).uint32(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.httpStatus = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.requestId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ForwardResponse>): ForwardResponse {
    return ForwardResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForwardResponse>): ForwardResponse {
    const message = createBaseForwardResponse();
    message.success = object.success ?? false;
    message.payload = object.payload ?? new Uint8Array(0);
    message.httpStatus = object.httpStatus ?? 0;
    message.error = object.error ?? "";
    message.requestId = object.requestId ?? 0;
    return message;
  },
};

function createBaseLogEntry(): LogEntry {
  return { timestampMs: 0n, level: 0, module: "", message: "", data: "" };
}

export const LogEntry: MessageFns<LogEntry> = {
  encode(message: LogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestampMs !== 0n) {
      if (BigInt.asUintN(64, message.timestampMs) !== message.timestampMs) {
        throw new globalThis.Error("value provided for field message.timestampMs of type uint64 too large");
      }
      writer.uint32(8).uint64(message.timestampMs);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    if (message.module !== "") {
      writer.uint32(26).string(message.module);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.data !== "") {
      writer.uint32(42).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestampMs = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LogEntry>): LogEntry {
    return LogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogEntry>): LogEntry {
    const message = createBaseLogEntry();
    message.timestampMs = object.timestampMs ?? 0n;
    message.level = object.level ?? 0;
    message.module = object.module ?? "";
    message.message = object.message ?? "";
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseLogResponse(): LogResponse {
  return { success: false, pendingCount: 0 };
}

export const LogResponse: MessageFns<LogResponse> = {
  encode(message: LogResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.pendingCount !== 0) {
      writer.uint32(16).uint32(message.pendingCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pendingCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LogResponse>): LogResponse {
    return LogResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogResponse>): LogResponse {
    const message = createBaseLogResponse();
    message.success = object.success ?? false;
    message.pendingCount = object.pendingCount ?? 0;
    return message;
  },
};

function createBasePingRequest(): PingRequest {
  return { clientTimestampMs: 0n };
}

export const PingRequest: MessageFns<PingRequest> = {
  encode(message: PingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientTimestampMs !== 0n) {
      if (BigInt.asUintN(64, message.clientTimestampMs) !== message.clientTimestampMs) {
        throw new globalThis.Error("value provided for field message.clientTimestampMs of type uint64 too large");
      }
      writer.uint32(8).uint64(message.clientTimestampMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.clientTimestampMs = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PingRequest>): PingRequest {
    return PingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PingRequest>): PingRequest {
    const message = createBasePingRequest();
    message.clientTimestampMs = object.clientTimestampMs ?? 0n;
    return message;
  },
};

function createBasePingResponse(): PingResponse {
  return { gatewayTimestampMs: 0n, clientTimestampMs: 0n };
}

export const PingResponse: MessageFns<PingResponse> = {
  encode(message: PingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gatewayTimestampMs !== 0n) {
      if (BigInt.asUintN(64, message.gatewayTimestampMs) !== message.gatewayTimestampMs) {
        throw new globalThis.Error("value provided for field message.gatewayTimestampMs of type uint64 too large");
      }
      writer.uint32(8).uint64(message.gatewayTimestampMs);
    }
    if (message.clientTimestampMs !== 0n) {
      if (BigInt.asUintN(64, message.clientTimestampMs) !== message.clientTimestampMs) {
        throw new globalThis.Error("value provided for field message.clientTimestampMs of type uint64 too large");
      }
      writer.uint32(16).uint64(message.clientTimestampMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gatewayTimestampMs = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clientTimestampMs = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PingResponse>): PingResponse {
    return PingResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PingResponse>): PingResponse {
    const message = createBasePingResponse();
    message.gatewayTimestampMs = object.gatewayTimestampMs ?? 0n;
    message.clientTimestampMs = object.clientTimestampMs ?? 0n;
    return message;
  },
};

/**
 * Gateway service for MACO device to MACO Gateway communication.
 *
 * The gateway acts as a proxy between MACO devices (P2) and Firebase Cloud
 * Functions. Devices communicate with the gateway over TCP using pw_rpc with
 * ASCON encryption. The gateway forwards requests to Firebase via HTTPS.
 *
 * This design allows:
 * - Adding new Firebase endpoints without gateway changes
 * - Central logging and monitoring on the gateway
 * - Key management isolated to the gateway
 */
export interface GatewayService {
  /**
   * Forward a request to Firebase Cloud Functions.
   *
   * The endpoint and payload are opaque to the gateway - it simply forwards
   * the request and returns the response. This allows adding new Firebase
   * endpoints without updating the gateway.
   *
   * Example endpoints:
   *   "/api/startSession" - Start a new session
   *   "/api/uploadUsage" - Upload usage data
   *   "/api/completeAuth" - Complete authentication
   */
  Forward(request: ForwardRequest): Promise<ForwardResponse>;
  /**
   * Persist a log entry on the gateway.
   *
   * Used for offline logging when Firebase is unreachable. Logs are stored
   * locally and can be synced later.
   */
  PersistLog(request: LogEntry): Promise<LogResponse>;
  /**
   * Ping the gateway to check connectivity.
   *
   * Returns the gateway's current timestamp. Can be used for connection
   * health checks and clock synchronization.
   */
  Ping(request: PingRequest): Promise<PingResponse>;
}

export const GatewayServiceServiceName = "maco.gateway.GatewayService";
export class GatewayServiceClientImpl implements GatewayService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || GatewayServiceServiceName;
    this.rpc = rpc;
    this.Forward = this.Forward.bind(this);
    this.PersistLog = this.PersistLog.bind(this);
    this.Ping = this.Ping.bind(this);
  }
  Forward(request: ForwardRequest): Promise<ForwardResponse> {
    const data = ForwardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Forward", data);
    return promise.then((data) => ForwardResponse.decode(new BinaryReader(data)));
  }

  PersistLog(request: LogEntry): Promise<LogResponse> {
    const data = LogEntry.encode(request).finish();
    const promise = this.rpc.request(this.service, "PersistLog", data);
    return promise.then((data) => LogResponse.decode(new BinaryReader(data)));
  }

  Ping(request: PingRequest): Promise<PingResponse> {
    const data = PingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Ping", data);
    return promise.then((data) => PingResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
