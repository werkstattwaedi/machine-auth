// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: firebase_rpc/auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { FirebaseId, Key, TagUid } from "../common";

export const protobufPackage = "maco.proto.firebase_rpc";

/** NTAG424 session keys for secure tag communication */
export interface SessionKeys {
  /** Derived session encryption key (AES-128) */
  sesAuthEncKey: Uint8Array;
  /** Derived session MAC key (AES-128) */
  sesAuthMacKey: Uint8Array;
  /** Transaction identifier from Part 3 response */
  transactionIdentifier: Uint8Array;
  /** PICC capabilities (PDcap2) from Part 3 response */
  piccCapabilities: Uint8Array;
}

/** Request was rejected */
export interface Rejected {
  /** User-readable message */
  message: string;
}

/** TerminalCheckin RPC - checks authorization and returns existing auth if available */
export interface TerminalCheckinRequest {
  tokenId: TagUid | undefined;
}

export interface TerminalCheckinResponse {
  result?: { $case: "authorized"; authorized: Authorized } | { $case: "rejected"; rejected: Rejected } | undefined;
}

/** User is authorized to use the machine */
export interface Authorized {
  /** Firebase user ID */
  userId:
    | FirebaseId
    | undefined;
  /** Display name for the user */
  userLabel: string;
  /**
   * If set, authentication is already complete and can be reused
   * If missing/empty, client must do auth flow before activating machine
   */
  authenticationId: FirebaseId | undefined;
}

/** AuthenticateTag RPC - initiates NTAG424 3-pass mutual authentication */
export interface AuthenticateTagRequest {
  /** Tag UID to authenticate */
  tagId:
    | TagUid
    | undefined;
  /** Which key slot to authenticate with */
  keySlot: Key;
  /** Encrypted RndB from tag (Part 1 response) */
  ntagChallenge: Uint8Array;
}

export interface AuthenticateTagResponse {
  /** Ephemeral authentication ID (~1 min validity for crypto completion) */
  authId:
    | FirebaseId
    | undefined;
  /** Combined challenge response to send to tag (Part 2) */
  cloudChallenge: Uint8Array;
}

/** CompleteTagAuth RPC - completes NTAG424 3-pass mutual authentication */
export interface CompleteTagAuthRequest {
  /** Authentication ID from AuthenticateTagResponse */
  authId:
    | FirebaseId
    | undefined;
  /** Encrypted Part 3 response from tag */
  encryptedTagResponse: Uint8Array;
}

export interface CompleteTagAuthResponse {
  result?:
    | //
    /** Authentication successful */
    { $case: "sessionKeys"; sessionKeys: SessionKeys }
    | //
    /** Authentication failed */
    { $case: "rejected"; rejected: Rejected }
    | undefined;
}

function createBaseSessionKeys(): SessionKeys {
  return {
    sesAuthEncKey: new Uint8Array(0),
    sesAuthMacKey: new Uint8Array(0),
    transactionIdentifier: new Uint8Array(0),
    piccCapabilities: new Uint8Array(0),
  };
}

export const SessionKeys: MessageFns<SessionKeys> = {
  encode(message: SessionKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sesAuthEncKey.length !== 0) {
      writer.uint32(10).bytes(message.sesAuthEncKey);
    }
    if (message.sesAuthMacKey.length !== 0) {
      writer.uint32(18).bytes(message.sesAuthMacKey);
    }
    if (message.transactionIdentifier.length !== 0) {
      writer.uint32(26).bytes(message.transactionIdentifier);
    }
    if (message.piccCapabilities.length !== 0) {
      writer.uint32(34).bytes(message.piccCapabilities);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sesAuthEncKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sesAuthMacKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactionIdentifier = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.piccCapabilities = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SessionKeys>): SessionKeys {
    return SessionKeys.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionKeys>): SessionKeys {
    const message = createBaseSessionKeys();
    message.sesAuthEncKey = object.sesAuthEncKey ?? new Uint8Array(0);
    message.sesAuthMacKey = object.sesAuthMacKey ?? new Uint8Array(0);
    message.transactionIdentifier = object.transactionIdentifier ?? new Uint8Array(0);
    message.piccCapabilities = object.piccCapabilities ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRejected(): Rejected {
  return { message: "" };
}

export const Rejected: MessageFns<Rejected> = {
  encode(message: Rejected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rejected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Rejected>): Rejected {
    return Rejected.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rejected>): Rejected {
    const message = createBaseRejected();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTerminalCheckinRequest(): TerminalCheckinRequest {
  return { tokenId: undefined };
}

export const TerminalCheckinRequest: MessageFns<TerminalCheckinRequest> = {
  encode(message: TerminalCheckinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== undefined) {
      TagUid.encode(message.tokenId, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminalCheckinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminalCheckinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenId = TagUid.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TerminalCheckinRequest>): TerminalCheckinRequest {
    return TerminalCheckinRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TerminalCheckinRequest>): TerminalCheckinRequest {
    const message = createBaseTerminalCheckinRequest();
    message.tokenId = (object.tokenId !== undefined && object.tokenId !== null)
      ? TagUid.fromPartial(object.tokenId)
      : undefined;
    return message;
  },
};

function createBaseTerminalCheckinResponse(): TerminalCheckinResponse {
  return { result: undefined };
}

export const TerminalCheckinResponse: MessageFns<TerminalCheckinResponse> = {
  encode(message: TerminalCheckinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.result?.$case) {
      case "authorized":
        Authorized.encode(message.result.authorized, writer.uint32(10).fork()).join();
        break;
      case "rejected":
        Rejected.encode(message.result.rejected, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminalCheckinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminalCheckinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = { $case: "authorized", authorized: Authorized.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = { $case: "rejected", rejected: Rejected.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TerminalCheckinResponse>): TerminalCheckinResponse {
    return TerminalCheckinResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TerminalCheckinResponse>): TerminalCheckinResponse {
    const message = createBaseTerminalCheckinResponse();
    switch (object.result?.$case) {
      case "authorized": {
        if (object.result?.authorized !== undefined && object.result?.authorized !== null) {
          message.result = { $case: "authorized", authorized: Authorized.fromPartial(object.result.authorized) };
        }
        break;
      }
      case "rejected": {
        if (object.result?.rejected !== undefined && object.result?.rejected !== null) {
          message.result = { $case: "rejected", rejected: Rejected.fromPartial(object.result.rejected) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseAuthorized(): Authorized {
  return { userId: undefined, userLabel: "", authenticationId: undefined };
}

export const Authorized: MessageFns<Authorized> = {
  encode(message: Authorized, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== undefined) {
      FirebaseId.encode(message.userId, writer.uint32(10).fork()).join();
    }
    if (message.userLabel !== "") {
      writer.uint32(18).string(message.userLabel);
    }
    if (message.authenticationId !== undefined) {
      FirebaseId.encode(message.authenticationId, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authorized {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorized();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = FirebaseId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userLabel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authenticationId = FirebaseId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Authorized>): Authorized {
    return Authorized.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Authorized>): Authorized {
    const message = createBaseAuthorized();
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? FirebaseId.fromPartial(object.userId)
      : undefined;
    message.userLabel = object.userLabel ?? "";
    message.authenticationId = (object.authenticationId !== undefined && object.authenticationId !== null)
      ? FirebaseId.fromPartial(object.authenticationId)
      : undefined;
    return message;
  },
};

function createBaseAuthenticateTagRequest(): AuthenticateTagRequest {
  return { tagId: undefined, keySlot: 0, ntagChallenge: new Uint8Array(0) };
}

export const AuthenticateTagRequest: MessageFns<AuthenticateTagRequest> = {
  encode(message: AuthenticateTagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagId !== undefined) {
      TagUid.encode(message.tagId, writer.uint32(10).fork()).join();
    }
    if (message.keySlot !== 0) {
      writer.uint32(16).int32(message.keySlot);
    }
    if (message.ntagChallenge.length !== 0) {
      writer.uint32(26).bytes(message.ntagChallenge);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticateTagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateTagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tagId = TagUid.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keySlot = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ntagChallenge = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AuthenticateTagRequest>): AuthenticateTagRequest {
    return AuthenticateTagRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthenticateTagRequest>): AuthenticateTagRequest {
    const message = createBaseAuthenticateTagRequest();
    message.tagId = (object.tagId !== undefined && object.tagId !== null)
      ? TagUid.fromPartial(object.tagId)
      : undefined;
    message.keySlot = object.keySlot ?? 0;
    message.ntagChallenge = object.ntagChallenge ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAuthenticateTagResponse(): AuthenticateTagResponse {
  return { authId: undefined, cloudChallenge: new Uint8Array(0) };
}

export const AuthenticateTagResponse: MessageFns<AuthenticateTagResponse> = {
  encode(message: AuthenticateTagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authId !== undefined) {
      FirebaseId.encode(message.authId, writer.uint32(10).fork()).join();
    }
    if (message.cloudChallenge.length !== 0) {
      writer.uint32(18).bytes(message.cloudChallenge);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticateTagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateTagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authId = FirebaseId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cloudChallenge = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AuthenticateTagResponse>): AuthenticateTagResponse {
    return AuthenticateTagResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthenticateTagResponse>): AuthenticateTagResponse {
    const message = createBaseAuthenticateTagResponse();
    message.authId = (object.authId !== undefined && object.authId !== null)
      ? FirebaseId.fromPartial(object.authId)
      : undefined;
    message.cloudChallenge = object.cloudChallenge ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCompleteTagAuthRequest(): CompleteTagAuthRequest {
  return { authId: undefined, encryptedTagResponse: new Uint8Array(0) };
}

export const CompleteTagAuthRequest: MessageFns<CompleteTagAuthRequest> = {
  encode(message: CompleteTagAuthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authId !== undefined) {
      FirebaseId.encode(message.authId, writer.uint32(10).fork()).join();
    }
    if (message.encryptedTagResponse.length !== 0) {
      writer.uint32(18).bytes(message.encryptedTagResponse);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteTagAuthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteTagAuthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authId = FirebaseId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encryptedTagResponse = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CompleteTagAuthRequest>): CompleteTagAuthRequest {
    return CompleteTagAuthRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteTagAuthRequest>): CompleteTagAuthRequest {
    const message = createBaseCompleteTagAuthRequest();
    message.authId = (object.authId !== undefined && object.authId !== null)
      ? FirebaseId.fromPartial(object.authId)
      : undefined;
    message.encryptedTagResponse = object.encryptedTagResponse ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCompleteTagAuthResponse(): CompleteTagAuthResponse {
  return { result: undefined };
}

export const CompleteTagAuthResponse: MessageFns<CompleteTagAuthResponse> = {
  encode(message: CompleteTagAuthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.result?.$case) {
      case "sessionKeys":
        SessionKeys.encode(message.result.sessionKeys, writer.uint32(10).fork()).join();
        break;
      case "rejected":
        Rejected.encode(message.result.rejected, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteTagAuthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteTagAuthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = { $case: "sessionKeys", sessionKeys: SessionKeys.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = { $case: "rejected", rejected: Rejected.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CompleteTagAuthResponse>): CompleteTagAuthResponse {
    return CompleteTagAuthResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteTagAuthResponse>): CompleteTagAuthResponse {
    const message = createBaseCompleteTagAuthResponse();
    switch (object.result?.$case) {
      case "sessionKeys": {
        if (object.result?.sessionKeys !== undefined && object.result?.sessionKeys !== null) {
          message.result = { $case: "sessionKeys", sessionKeys: SessionKeys.fromPartial(object.result.sessionKeys) };
        }
        break;
      }
      case "rejected": {
        if (object.result?.rejected !== undefined && object.result?.rejected !== null) {
          message.result = { $case: "rejected", rejected: Rejected.fromPartial(object.result.rejected) };
        }
        break;
      }
    }
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
